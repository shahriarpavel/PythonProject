<html>
<head>
<title>typing_extensions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typing_extensions.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">builtins</span>
<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">contextlib</span>
<span class="s0">import </span><span class="s1">enum</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">keyword</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">types </span><span class="s0">as </span><span class="s1">_types</span>
<span class="s0">import </span><span class="s1">typing</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s1">__all__ </span><span class="s2">= [</span>
    <span class="s3"># Super-special typing primitives.</span>
    <span class="s4">'Any'</span><span class="s2">,</span>
    <span class="s4">'ClassVar'</span><span class="s2">,</span>
    <span class="s4">'Concatenate'</span><span class="s2">,</span>
    <span class="s4">'Final'</span><span class="s2">,</span>
    <span class="s4">'LiteralString'</span><span class="s2">,</span>
    <span class="s4">'ParamSpec'</span><span class="s2">,</span>
    <span class="s4">'ParamSpecArgs'</span><span class="s2">,</span>
    <span class="s4">'ParamSpecKwargs'</span><span class="s2">,</span>
    <span class="s4">'Self'</span><span class="s2">,</span>
    <span class="s4">'Type'</span><span class="s2">,</span>
    <span class="s4">'TypeVar'</span><span class="s2">,</span>
    <span class="s4">'TypeVarTuple'</span><span class="s2">,</span>
    <span class="s4">'Unpack'</span><span class="s2">,</span>

    <span class="s3"># ABCs (from collections.abc).</span>
    <span class="s4">'Awaitable'</span><span class="s2">,</span>
    <span class="s4">'AsyncIterator'</span><span class="s2">,</span>
    <span class="s4">'AsyncIterable'</span><span class="s2">,</span>
    <span class="s4">'Coroutine'</span><span class="s2">,</span>
    <span class="s4">'AsyncGenerator'</span><span class="s2">,</span>
    <span class="s4">'AsyncContextManager'</span><span class="s2">,</span>
    <span class="s4">'Buffer'</span><span class="s2">,</span>
    <span class="s4">'ChainMap'</span><span class="s2">,</span>

    <span class="s3"># Concrete collection types.</span>
    <span class="s4">'ContextManager'</span><span class="s2">,</span>
    <span class="s4">'Counter'</span><span class="s2">,</span>
    <span class="s4">'Deque'</span><span class="s2">,</span>
    <span class="s4">'DefaultDict'</span><span class="s2">,</span>
    <span class="s4">'NamedTuple'</span><span class="s2">,</span>
    <span class="s4">'OrderedDict'</span><span class="s2">,</span>
    <span class="s4">'TypedDict'</span><span class="s2">,</span>

    <span class="s3"># Structural checks, a.k.a. protocols.</span>
    <span class="s4">'SupportsAbs'</span><span class="s2">,</span>
    <span class="s4">'SupportsBytes'</span><span class="s2">,</span>
    <span class="s4">'SupportsComplex'</span><span class="s2">,</span>
    <span class="s4">'SupportsFloat'</span><span class="s2">,</span>
    <span class="s4">'SupportsIndex'</span><span class="s2">,</span>
    <span class="s4">'SupportsInt'</span><span class="s2">,</span>
    <span class="s4">'SupportsRound'</span><span class="s2">,</span>

    <span class="s3"># One-off things.</span>
    <span class="s4">'Annotated'</span><span class="s2">,</span>
    <span class="s4">'assert_never'</span><span class="s2">,</span>
    <span class="s4">'assert_type'</span><span class="s2">,</span>
    <span class="s4">'clear_overloads'</span><span class="s2">,</span>
    <span class="s4">'dataclass_transform'</span><span class="s2">,</span>
    <span class="s4">'deprecated'</span><span class="s2">,</span>
    <span class="s4">'Doc'</span><span class="s2">,</span>
    <span class="s4">'evaluate_forward_ref'</span><span class="s2">,</span>
    <span class="s4">'get_overloads'</span><span class="s2">,</span>
    <span class="s4">'final'</span><span class="s2">,</span>
    <span class="s4">'Format'</span><span class="s2">,</span>
    <span class="s4">'get_annotations'</span><span class="s2">,</span>
    <span class="s4">'get_args'</span><span class="s2">,</span>
    <span class="s4">'get_origin'</span><span class="s2">,</span>
    <span class="s4">'get_original_bases'</span><span class="s2">,</span>
    <span class="s4">'get_protocol_members'</span><span class="s2">,</span>
    <span class="s4">'get_type_hints'</span><span class="s2">,</span>
    <span class="s4">'IntVar'</span><span class="s2">,</span>
    <span class="s4">'is_protocol'</span><span class="s2">,</span>
    <span class="s4">'is_typeddict'</span><span class="s2">,</span>
    <span class="s4">'Literal'</span><span class="s2">,</span>
    <span class="s4">'NewType'</span><span class="s2">,</span>
    <span class="s4">'overload'</span><span class="s2">,</span>
    <span class="s4">'override'</span><span class="s2">,</span>
    <span class="s4">'Protocol'</span><span class="s2">,</span>
    <span class="s4">'reveal_type'</span><span class="s2">,</span>
    <span class="s4">'runtime'</span><span class="s2">,</span>
    <span class="s4">'runtime_checkable'</span><span class="s2">,</span>
    <span class="s4">'Text'</span><span class="s2">,</span>
    <span class="s4">'TypeAlias'</span><span class="s2">,</span>
    <span class="s4">'TypeAliasType'</span><span class="s2">,</span>
    <span class="s4">'TypeForm'</span><span class="s2">,</span>
    <span class="s4">'TypeGuard'</span><span class="s2">,</span>
    <span class="s4">'TypeIs'</span><span class="s2">,</span>
    <span class="s4">'TYPE_CHECKING'</span><span class="s2">,</span>
    <span class="s4">'Never'</span><span class="s2">,</span>
    <span class="s4">'NoReturn'</span><span class="s2">,</span>
    <span class="s4">'ReadOnly'</span><span class="s2">,</span>
    <span class="s4">'Required'</span><span class="s2">,</span>
    <span class="s4">'NotRequired'</span><span class="s2">,</span>
    <span class="s4">'NoDefault'</span><span class="s2">,</span>
    <span class="s4">'NoExtraItems'</span><span class="s2">,</span>

    <span class="s3"># Pure aliases, have always been in typing</span>
    <span class="s4">'AbstractSet'</span><span class="s2">,</span>
    <span class="s4">'AnyStr'</span><span class="s2">,</span>
    <span class="s4">'BinaryIO'</span><span class="s2">,</span>
    <span class="s4">'Callable'</span><span class="s2">,</span>
    <span class="s4">'Collection'</span><span class="s2">,</span>
    <span class="s4">'Container'</span><span class="s2">,</span>
    <span class="s4">'Dict'</span><span class="s2">,</span>
    <span class="s4">'ForwardRef'</span><span class="s2">,</span>
    <span class="s4">'FrozenSet'</span><span class="s2">,</span>
    <span class="s4">'Generator'</span><span class="s2">,</span>
    <span class="s4">'Generic'</span><span class="s2">,</span>
    <span class="s4">'Hashable'</span><span class="s2">,</span>
    <span class="s4">'IO'</span><span class="s2">,</span>
    <span class="s4">'ItemsView'</span><span class="s2">,</span>
    <span class="s4">'Iterable'</span><span class="s2">,</span>
    <span class="s4">'Iterator'</span><span class="s2">,</span>
    <span class="s4">'KeysView'</span><span class="s2">,</span>
    <span class="s4">'List'</span><span class="s2">,</span>
    <span class="s4">'Mapping'</span><span class="s2">,</span>
    <span class="s4">'MappingView'</span><span class="s2">,</span>
    <span class="s4">'Match'</span><span class="s2">,</span>
    <span class="s4">'MutableMapping'</span><span class="s2">,</span>
    <span class="s4">'MutableSequence'</span><span class="s2">,</span>
    <span class="s4">'MutableSet'</span><span class="s2">,</span>
    <span class="s4">'Optional'</span><span class="s2">,</span>
    <span class="s4">'Pattern'</span><span class="s2">,</span>
    <span class="s4">'Reversible'</span><span class="s2">,</span>
    <span class="s4">'Sequence'</span><span class="s2">,</span>
    <span class="s4">'Set'</span><span class="s2">,</span>
    <span class="s4">'Sized'</span><span class="s2">,</span>
    <span class="s4">'TextIO'</span><span class="s2">,</span>
    <span class="s4">'Tuple'</span><span class="s2">,</span>
    <span class="s4">'Union'</span><span class="s2">,</span>
    <span class="s4">'ValuesView'</span><span class="s2">,</span>
    <span class="s4">'cast'</span><span class="s2">,</span>
    <span class="s4">'no_type_check'</span><span class="s2">,</span>
    <span class="s4">'no_type_check_decorator'</span><span class="s2">,</span>
<span class="s2">]</span>

<span class="s3"># for backward compatibility</span>
<span class="s1">PEP_560 </span><span class="s2">= </span><span class="s0">True</span>
<span class="s1">GenericMeta </span><span class="s2">= </span><span class="s1">type</span>
<span class="s1">_PEP_696_IMPLEMENTED </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s4">&quot;beta&quot;</span><span class="s2">)</span>

<span class="s3"># Added with bpo-45166 to 3.10.1+ and some 3.9 versions</span>
<span class="s1">_FORWARD_REF_HAS_CLASS </span><span class="s2">= </span><span class="s4">&quot;__forward_is_class__&quot; </span><span class="s0">in </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ForwardRef</span><span class="s2">.</span><span class="s1">__slots__</span>

<span class="s3"># The functions below are modified copies of typing internal helpers.</span>
<span class="s3"># They are needed by _ProtocolMeta and they provide support for PEP 646.</span>


<span class="s0">class </span><span class="s1">_Sentinel</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">&quot;&lt;sentinel&gt;&quot;</span>


<span class="s1">_marker </span><span class="s2">= </span><span class="s1">_Sentinel</span><span class="s2">()</span>


<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">_should_collect_from_parameters</span><span class="s2">(</span><span class="s1">t</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span>
            <span class="s1">t</span><span class="s2">, (</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">UnionType</span><span class="s2">)</span>
        <span class="s2">)</span>
<span class="s0">elif </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">_should_collect_from_parameters</span><span class="s2">(</span><span class="s1">t</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, (</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">))</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">_should_collect_from_parameters</span><span class="s2">(</span><span class="s1">t</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">t</span><span class="s2">.</span><span class="s1">_special</span>


<span class="s1">NoReturn </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">NoReturn</span>

<span class="s3"># Some unconstrained type variables.  These are used by the container types.</span>
<span class="s3"># (These are not for export.)</span>
<span class="s1">T </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s4">'T'</span><span class="s2">)  </span><span class="s3"># Any type.</span>
<span class="s1">KT </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s4">'KT'</span><span class="s2">)  </span><span class="s3"># Key type.</span>
<span class="s1">VT </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s4">'VT'</span><span class="s2">)  </span><span class="s3"># Value type.</span>
<span class="s1">T_co </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s4">'T_co'</span><span class="s2">, </span><span class="s1">covariant</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)  </span><span class="s3"># Any type covariant containers.</span>
<span class="s1">T_contra </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s4">'T_contra'</span><span class="s2">, </span><span class="s1">contravariant</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)  </span><span class="s3"># Ditto contravariant.</span>


<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">11</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span>
<span class="s0">else</span><span class="s2">:</span>

    <span class="s0">class </span><span class="s1">_AnyMeta</span><span class="s2">(</span><span class="s1">type</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__instancecheck__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">is </span><span class="s1">Any</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;typing_extensions.Any cannot be used with isinstance()&quot;</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__instancecheck__</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">is </span><span class="s1">Any</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s4">&quot;typing_extensions.Any&quot;</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__repr__</span><span class="s2">()</span>

    <span class="s0">class </span><span class="s1">Any</span><span class="s2">(</span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">_AnyMeta</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Special type indicating an unconstrained type. 
        - Any is compatible with every type. 
        - Any assumed to have all methods. 
        - All values assumed to be instances of Any. 
        Note that all the above statements are true from the point of view of 
        static type checkers. At runtime, Any should not be used with instance 
        checks. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Any</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Any cannot be instantiated&quot;</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>


<span class="s1">ClassVar </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ClassVar</span>


<span class="s0">class </span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_SpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">'typing_extensions.' </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span>


<span class="s1">Final </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Final</span>

<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">11</span><span class="s2">):</span>
    <span class="s1">final </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">final</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s3"># @final exists in 3.8+, but we backport it for all versions</span>
    <span class="s3"># before 3.11 to keep support for the __final__ attribute.</span>
    <span class="s3"># See https://bugs.python.org/issue46342</span>
    <span class="s0">def </span><span class="s1">final</span><span class="s2">(</span><span class="s1">f</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;This decorator can be used to indicate to type checkers that 
        the decorated method cannot be overridden, and decorated class 
        cannot be subclassed. For example: 
 
            class Base: 
                @final 
                def done(self) -&gt; None: 
                    ... 
            class Sub(Base): 
                def done(self) -&gt; None:  # Error reported by type checker 
                    ... 
            @final 
            class Leaf: 
                ... 
            class Other(Leaf):  # Error reported by type checker 
                ... 
 
        There is no runtime checking of these properties. The decorator 
        sets the ``__final__`` attribute to ``True`` on the decorated object 
        to allow runtime introspection. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">f</span><span class="s2">.</span><span class="s1">__final__ </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
            <span class="s3"># Skip the attribute silently if it is not writable.</span>
            <span class="s3"># AttributeError happens if the object has __slots__ or a</span>
            <span class="s3"># read-only property, TypeError if it's a builtin class.</span>
            <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">f</span>


<span class="s0">def </span><span class="s1">IntVar</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>


<span class="s3"># A Literal bug was fixed in 3.11.0, 3.10.1 and 3.9.8</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s2">):</span>
    <span class="s1">Literal </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Literal</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">_flatten_literal_params</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;An internal helper for Literal creation: flatten Literals among parameters&quot;&quot;&quot;</span>
        <span class="s1">params </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">_LiteralGenericAlias</span><span class="s2">):</span>
                <span class="s1">params</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">p</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">params</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">params</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_value_and_type_iter</span><span class="s2">(</span><span class="s1">params</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params</span><span class="s2">:</span>
            <span class="s0">yield </span><span class="s1">p</span><span class="s2">, </span><span class="s1">type</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>

    <span class="s0">class </span><span class="s1">_LiteralGenericAlias</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">_LiteralGenericAlias</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s1">these_args_deduped </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">_value_and_type_iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">))</span>
            <span class="s1">other_args_deduped </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">_value_and_type_iter</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">))</span>
            <span class="s0">return </span><span class="s1">these_args_deduped </span><span class="s2">== </span><span class="s1">other_args_deduped</span>

        <span class="s0">def </span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">hash</span><span class="s2">(</span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">_value_and_type_iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">)))</span>

    <span class="s0">class </span><span class="s1">_LiteralForm</span><span class="s2">(</span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">: </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_name </span><span class="s2">= </span><span class="s4">'Literal'</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_doc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">doc</span>

        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s1">parameters </span><span class="s2">= (</span><span class="s1">parameters</span><span class="s2">,)</span>

            <span class="s1">parameters </span><span class="s2">= </span><span class="s1">_flatten_literal_params</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">)</span>

            <span class="s1">val_type_pairs </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">_value_and_type_iter</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">))</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">deduped_pairs </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">val_type_pairs</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
                <span class="s3"># unhashable parameters</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># similar logic to typing._deduplicate on Python 3.9+</span>
                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deduped_pairs</span><span class="s2">) &lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">val_type_pairs</span><span class="s2">):</span>
                    <span class="s1">new_parameters </span><span class="s2">= []</span>
                    <span class="s0">for </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">val_type_pairs</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">deduped_pairs</span><span class="s2">:</span>
                            <span class="s1">new_parameters</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">pair</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
                            <span class="s1">deduped_pairs</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">pair</span><span class="s2">)</span>
                    <span class="s0">assert not </span><span class="s1">deduped_pairs</span><span class="s2">, </span><span class="s1">deduped_pairs</span>
                    <span class="s1">parameters </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">new_parameters</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">_LiteralGenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">)</span>

    <span class="s1">Literal </span><span class="s2">= </span><span class="s1">_LiteralForm</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">=</span><span class="s4">&quot;&quot;&quot;</span><span class="s0">\ 
                           </span><span class="s4">A type that can be used to indicate to type checkers 
                           that the corresponding value has a value literally equivalent 
                           to the provided parameter. For example: 
 
                               var: Literal[4] = 4 
 
                           The type checker understands that 'var' is literally equal to 
                           the value 4 and no other value. 
 
                           Literal[...] cannot be subclassed. There is no runtime 
                           checking verifying that the parameter is actually a value 
                           instead of a type.&quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s1">_overload_dummy </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_overload_dummy</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;get_overloads&quot;</span><span class="s2">):  </span><span class="s3"># 3.11+</span>
    <span class="s1">overload </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">overload</span>
    <span class="s1">get_overloads </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">get_overloads</span>
    <span class="s1">clear_overloads </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">clear_overloads</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s3"># {module: {qualname: {firstlineno: func}}}</span>
    <span class="s1">_overload_registry </span><span class="s2">= </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">defaultdict</span><span class="s2">(</span>
        <span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">collections</span><span class="s2">.</span><span class="s1">defaultdict</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">)</span>
    <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">overload</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Decorator for overloaded functions/methods. 
 
        In a stub file, place two or more stub definitions for the same 
        function in a row, each decorated with @overload.  For example: 
 
        @overload 
        def utf8(value: None) -&gt; None: ... 
        @overload 
        def utf8(value: bytes) -&gt; bytes: ... 
        @overload 
        def utf8(value: str) -&gt; bytes: ... 
 
        In a non-stub file (i.e. a regular .py file), do the same but 
        follow it with an implementation.  The implementation should *not* 
        be decorated with @overload.  For example: 
 
        @overload 
        def utf8(value: None) -&gt; None: ... 
        @overload 
        def utf8(value: bytes) -&gt; bytes: ... 
        @overload 
        def utf8(value: str) -&gt; bytes: ... 
        def utf8(value): 
            # implementation goes here 
 
        The overloads for a function can be retrieved at runtime using the 
        get_overloads() function. 
        &quot;&quot;&quot;</span>
        <span class="s3"># classmethod and staticmethod</span>
        <span class="s1">f </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s4">&quot;__func__&quot;</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">_overload_registry</span><span class="s2">[</span><span class="s1">f</span><span class="s2">.</span><span class="s1">__module__</span><span class="s2">][</span><span class="s1">f</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s2">][</span>
                <span class="s1">f</span><span class="s2">.</span><span class="s1">__code__</span><span class="s2">.</span><span class="s1">co_firstlineno</span>
            <span class="s2">] = </span><span class="s1">func</span>
        <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
            <span class="s3"># Not a normal function; ignore.</span>
            <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">_overload_dummy</span>

    <span class="s0">def </span><span class="s1">get_overloads</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Return all defined overloads for *func* as a sequence.&quot;&quot;&quot;</span>
        <span class="s3"># classmethod and staticmethod</span>
        <span class="s1">f </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s4">&quot;__func__&quot;</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__module__ </span><span class="s0">not in </span><span class="s1">_overload_registry</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">[]</span>
        <span class="s1">mod_dict </span><span class="s2">= </span><span class="s1">_overload_registry</span><span class="s2">[</span><span class="s1">f</span><span class="s2">.</span><span class="s1">__module__</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">f</span><span class="s2">.</span><span class="s1">__qualname__ </span><span class="s0">not in </span><span class="s1">mod_dict</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">[]</span>
        <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">mod_dict</span><span class="s2">[</span><span class="s1">f</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s2">].</span><span class="s1">values</span><span class="s2">())</span>

    <span class="s0">def </span><span class="s1">clear_overloads</span><span class="s2">():</span>
        <span class="s6">&quot;&quot;&quot;Clear all overloads in the registry.&quot;&quot;&quot;</span>
        <span class="s1">_overload_registry</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>


<span class="s3"># This is not a real generic class.  Don't use outside annotations.</span>
<span class="s1">Type </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Type</span>

<span class="s3"># Various ABCs mimicking those in collections.abc.</span>
<span class="s3"># A few are simply re-exported for completeness.</span>
<span class="s1">Awaitable </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Awaitable</span>
<span class="s1">Coroutine </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Coroutine</span>
<span class="s1">AsyncIterable </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">AsyncIterable</span>
<span class="s1">AsyncIterator </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">AsyncIterator</span>
<span class="s1">Deque </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Deque</span>
<span class="s1">DefaultDict </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">DefaultDict</span>
<span class="s1">OrderedDict </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">OrderedDict</span>
<span class="s1">Counter </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Counter</span>
<span class="s1">ChainMap </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ChainMap</span>
<span class="s1">Text </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Text</span>
<span class="s1">TYPE_CHECKING </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TYPE_CHECKING</span>


<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s4">&quot;beta&quot;</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">AsyncContextManager</span><span class="s2">, </span><span class="s1">AsyncGenerator</span><span class="s2">, </span><span class="s1">ContextManager</span><span class="s2">, </span><span class="s1">Generator</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">_is_dunder</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s4">'__'</span><span class="s2">) </span><span class="s0">and </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">endswith</span><span class="s2">(</span><span class="s4">'__'</span><span class="s2">)</span>

    <span class="s3"># Python &lt;3.9 doesn't have typing._SpecialGenericAlias</span>
    <span class="s1">_special_generic_alias_base </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span>
        <span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;_SpecialGenericAlias&quot;</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span>
    <span class="s2">)</span>

    <span class="s0">class </span><span class="s1">_SpecialGenericAlias</span><span class="s2">(</span><span class="s1">_special_generic_alias_base</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">nparams</span><span class="s2">, *, </span><span class="s1">inst</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">defaults</span><span class="s2">=()):</span>
            <span class="s0">if </span><span class="s1">_special_generic_alias_base </span><span class="s0">is </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">:</span>
                <span class="s3"># Python &lt;3.9</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s2">= </span><span class="s1">origin</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_nparams </span><span class="s2">= </span><span class="s1">nparams</span>
                <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">nparams</span><span class="s2">, </span><span class="s1">special</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">inst</span><span class="s2">=</span><span class="s1">inst</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># Python &gt;= 3.9</span>
                <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">nparams</span><span class="s2">, </span><span class="s1">inst</span><span class="s2">=</span><span class="s1">inst</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_defaults </span><span class="s2">= </span><span class="s1">defaults</span>

        <span class="s0">def </span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
            <span class="s1">allowed_attrs </span><span class="s2">= {</span><span class="s4">'_name'</span><span class="s2">, </span><span class="s4">'_inst'</span><span class="s2">, </span><span class="s4">'_nparams'</span><span class="s2">, </span><span class="s4">'_defaults'</span><span class="s2">}</span>
            <span class="s0">if </span><span class="s1">_special_generic_alias_base </span><span class="s0">is </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">:</span>
                <span class="s3"># Python &lt;3.9</span>
                <span class="s1">allowed_attrs</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s4">&quot;__origin__&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">_is_dunder</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">) </span><span class="s0">or </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">allowed_attrs</span><span class="s2">:</span>
                <span class="s1">object</span><span class="s2">.</span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">setattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_tp_cache</span>
        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">params</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s1">params </span><span class="s2">= (</span><span class="s1">params</span><span class="s2">,)</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;Parameters to generic types must be types.&quot;</span>
            <span class="s1">params </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_defaults</span>
                <span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">) &lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_nparams</span>
                <span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">) + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_defaults</span><span class="s2">) &gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_nparams</span>
            <span class="s2">):</span>
                <span class="s1">params </span><span class="s2">= (*</span><span class="s1">params</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_defaults</span><span class="s2">[</span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">) - </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_nparams</span><span class="s2">:])</span>
            <span class="s1">actual_len </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">actual_len </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_nparams</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_defaults</span><span class="s2">:</span>
                    <span class="s1">expected </span><span class="s2">= </span><span class="s4">f&quot;at least </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_nparams </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_defaults</span><span class="s2">)</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">expected </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_nparams</span><span class="s2">)</span>
                <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_nparams</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">is not a generic class&quot;</span><span class="s2">)</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                    <span class="s4">f&quot;Too </span><span class="s0">{</span><span class="s4">'many' </span><span class="s0">if </span><span class="s1">actual_len </span><span class="s2">&gt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_nparams </span><span class="s0">else </span><span class="s4">'few'</span><span class="s0">}</span><span class="s4">&quot;</span>
                    <span class="s4">f&quot; arguments for </span><span class="s0">{</span><span class="s1">self</span><span class="s0">}</span><span class="s4">;&quot;</span>
                    <span class="s4">f&quot; actual </span><span class="s0">{</span><span class="s1">actual_len</span><span class="s0">}</span><span class="s4">, expected </span><span class="s0">{</span><span class="s1">expected</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy_with</span><span class="s2">(</span><span class="s1">params</span><span class="s2">)</span>

    <span class="s1">_NoneType </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
    <span class="s1">Generator </span><span class="s2">= </span><span class="s1">_SpecialGenericAlias</span><span class="s2">(</span>
        <span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Generator</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">defaults</span><span class="s2">=(</span><span class="s1">_NoneType</span><span class="s2">, </span><span class="s1">_NoneType</span><span class="s2">)</span>
    <span class="s2">)</span>
    <span class="s1">AsyncGenerator </span><span class="s2">= </span><span class="s1">_SpecialGenericAlias</span><span class="s2">(</span>
        <span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">AsyncGenerator</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">defaults</span><span class="s2">=(</span><span class="s1">_NoneType</span><span class="s2">,)</span>
    <span class="s2">)</span>
    <span class="s1">ContextManager </span><span class="s2">= </span><span class="s1">_SpecialGenericAlias</span><span class="s2">(</span>
        <span class="s1">contextlib</span><span class="s2">.</span><span class="s1">AbstractContextManager</span><span class="s2">,</span>
        <span class="s5">2</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s4">&quot;ContextManager&quot;</span><span class="s2">,</span>
        <span class="s1">defaults</span><span class="s2">=(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">bool</span><span class="s2">],)</span>
    <span class="s2">)</span>
    <span class="s1">AsyncContextManager </span><span class="s2">= </span><span class="s1">_SpecialGenericAlias</span><span class="s2">(</span>
        <span class="s1">contextlib</span><span class="s2">.</span><span class="s1">AbstractAsyncContextManager</span><span class="s2">,</span>
        <span class="s5">2</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s4">&quot;AsyncContextManager&quot;</span><span class="s2">,</span>
        <span class="s1">defaults</span><span class="s2">=(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">bool</span><span class="s2">],)</span>
    <span class="s2">)</span>


<span class="s1">_PROTO_ALLOWLIST </span><span class="s2">= {</span>
    <span class="s4">'collections.abc'</span><span class="s2">: [</span>
        <span class="s4">'Callable'</span><span class="s2">, </span><span class="s4">'Awaitable'</span><span class="s2">, </span><span class="s4">'Iterable'</span><span class="s2">, </span><span class="s4">'Iterator'</span><span class="s2">, </span><span class="s4">'AsyncIterable'</span><span class="s2">,</span>
        <span class="s4">'Hashable'</span><span class="s2">, </span><span class="s4">'Sized'</span><span class="s2">, </span><span class="s4">'Container'</span><span class="s2">, </span><span class="s4">'Collection'</span><span class="s2">, </span><span class="s4">'Reversible'</span><span class="s2">, </span><span class="s4">'Buffer'</span><span class="s2">,</span>
    <span class="s2">],</span>
    <span class="s4">'contextlib'</span><span class="s2">: [</span><span class="s4">'AbstractContextManager'</span><span class="s2">, </span><span class="s4">'AbstractAsyncContextManager'</span><span class="s2">],</span>
    <span class="s4">'typing_extensions'</span><span class="s2">: [</span><span class="s4">'Buffer'</span><span class="s2">],</span>
<span class="s2">}</span>


<span class="s1">_EXCLUDED_ATTRS </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">EXCLUDED_ATTRIBUTES</span><span class="s2">) | {</span>
    <span class="s4">&quot;__match_args__&quot;</span><span class="s2">, </span><span class="s4">&quot;__protocol_attrs__&quot;</span><span class="s2">, </span><span class="s4">&quot;__non_callable_proto_members__&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;__final__&quot;</span><span class="s2">,</span>
<span class="s2">}</span>


<span class="s0">def </span><span class="s1">_get_protocol_attrs</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">):</span>
    <span class="s1">attrs </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__mro__</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">]:  </span><span class="s3"># without object</span>
        <span class="s0">if </span><span class="s1">base</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s0">in </span><span class="s2">{</span><span class="s4">'Protocol'</span><span class="s2">, </span><span class="s4">'Generic'</span><span class="s2">}:</span>
            <span class="s0">continue</span>
        <span class="s1">annotations </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">base</span><span class="s2">, </span><span class="s4">'__annotations__'</span><span class="s2">, {})</span>
        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s2">(*</span><span class="s1">base</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">, *</span><span class="s1">annotations</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s0">not </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s4">'_abc_'</span><span class="s2">) </span><span class="s0">and </span><span class="s1">attr </span><span class="s0">not in </span><span class="s1">_EXCLUDED_ATTRS</span><span class="s2">):</span>
                <span class="s1">attrs</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">attrs</span>


<span class="s0">def </span><span class="s1">_caller</span><span class="s2">(</span><span class="s1">depth</span><span class="s2">=</span><span class="s5">2</span><span class="s2">):</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">_getframe</span><span class="s2">(</span><span class="s1">depth</span><span class="s2">).</span><span class="s1">f_globals</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'__name__'</span><span class="s2">, </span><span class="s4">'__main__'</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s2">(</span><span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">):  </span><span class="s3"># For platforms without _getframe()</span>
        <span class="s0">return None</span>


<span class="s3"># `__match_args__` attribute was removed from protocol members in 3.13,</span>
<span class="s3"># we want to backport this change to older Python versions.</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">13</span><span class="s2">):</span>
    <span class="s1">Protocol </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Protocol</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">_allow_reckless_class_checks</span><span class="s2">(</span><span class="s1">depth</span><span class="s2">=</span><span class="s5">3</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Allow instance and class checks for special stdlib modules. 
        The abc and functools modules indiscriminately call isinstance() and 
        issubclass() on the whole MRO of a user class, which may contain protocols. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_caller</span><span class="s2">(</span><span class="s1">depth</span><span class="s2">) </span><span class="s0">in </span><span class="s2">{</span><span class="s4">'abc'</span><span class="s2">, </span><span class="s4">'functools'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">}</span>

    <span class="s0">def </span><span class="s1">_no_init</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">_is_protocol</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">'Protocols cannot be instantiated'</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_type_check_issubclass_arg_1</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Raise TypeError if `arg` is not an instance of `type` 
        in `issubclass(arg, &lt;protocol&gt;)`. 
 
        In most cases, this is verified by type.__subclasscheck__. 
        Checking it again unnecessarily would slow down issubclass() checks, 
        so, we don't perform this check unless we absolutely have to. 
 
        For various error paths, however, 
        we want to ensure that *this* error message is shown to the user 
        where relevant, rather than a typing.py-specific error message. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
            <span class="s3"># Same error message as for issubclass(1, int).</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">'issubclass() arg 1 must be a class'</span><span class="s2">)</span>

    <span class="s3"># Inheriting from typing._ProtocolMeta isn't actually desirable,</span>
    <span class="s3"># but is necessary to allow typing.Protocol and typing_extensions.Protocol</span>
    <span class="s3"># to mix without getting TypeErrors about &quot;metaclass conflict&quot;</span>
    <span class="s0">class </span><span class="s1">_ProtocolMeta</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Protocol</span><span class="s2">)):</span>
        <span class="s3"># This metaclass is somewhat unfortunate,</span>
        <span class="s3"># but is necessary for several reasons...</span>
        <span class="s3">#</span>
        <span class="s3"># NOTE: DO NOT call super() in any methods in this class</span>
        <span class="s3"># That would call the methods on typing._ProtocolMeta on Python 3.8-3.11</span>
        <span class="s3"># and those are slow</span>
        <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">mcls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s4">&quot;Protocol&quot; </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">bases</span><span class="s2">) &lt; </span><span class="s5">2</span><span class="s2">:</span>
                <span class="s0">pass</span>
            <span class="s0">elif </span><span class="s2">{</span><span class="s1">Protocol</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Protocol</span><span class="s2">} &amp; </span><span class="s1">set</span><span class="s2">(</span><span class="s1">bases</span><span class="s2">):</span>
                <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases</span><span class="s2">:</span>
                    <span class="s0">if not </span><span class="s2">(</span>
                        <span class="s1">base </span><span class="s0">in </span><span class="s2">{</span><span class="s1">object</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span><span class="s2">, </span><span class="s1">Protocol</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Protocol</span><span class="s2">}</span>
                        <span class="s0">or </span><span class="s1">base</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s0">in </span><span class="s1">_PROTO_ALLOWLIST</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">base</span><span class="s2">.</span><span class="s1">__module__</span><span class="s2">, [])</span>
                        <span class="s0">or </span><span class="s1">is_protocol</span><span class="s2">(</span><span class="s1">base</span><span class="s2">)</span>
                    <span class="s2">):</span>
                        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                            <span class="s4">f&quot;Protocols can only inherit from other protocols, &quot;</span>
                            <span class="s4">f&quot;got </span><span class="s0">{</span><span class="s1">base</span><span class="s0">!r}</span><span class="s4">&quot;</span>
                        <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">abc</span><span class="s2">.</span><span class="s1">ABCMeta</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">mcls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">abc</span><span class="s2">.</span><span class="s1">ABCMeta</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s4">&quot;_is_protocol&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
                <span class="s1">cls</span><span class="s2">.</span><span class="s1">__protocol_attrs__ </span><span class="s2">= </span><span class="s1">_get_protocol_attrs</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__subclasscheck__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Protocol</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">type</span><span class="s2">.</span><span class="s1">__subclasscheck__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s2">(</span>
                <span class="s1">getattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s4">'_is_protocol'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
                <span class="s0">and not </span><span class="s1">_allow_reckless_class_checks</span><span class="s2">()</span>
            <span class="s2">):</span>
                <span class="s0">if not </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s4">'_is_runtime_protocol'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
                    <span class="s1">_type_check_issubclass_arg_1</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                        <span class="s4">&quot;Instance and class checks can only be used with &quot;</span>
                        <span class="s4">&quot;@runtime_checkable protocols&quot;</span>
                    <span class="s2">)</span>
                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s3"># this attribute is set by @runtime_checkable:</span>
                    <span class="s1">cls</span><span class="s2">.</span><span class="s1">__non_callable_proto_members__</span>
                    <span class="s0">and </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;__subclasshook__&quot;</span><span class="s2">) </span><span class="s0">is </span><span class="s1">_proto_hook</span>
                <span class="s2">):</span>
                    <span class="s1">_type_check_issubclass_arg_1</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
                    <span class="s1">non_method_attrs </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__non_callable_proto_members__</span><span class="s2">)</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                        <span class="s4">&quot;Protocols with non-method members don't support issubclass().&quot;</span>
                        <span class="s4">f&quot; Non-method members: </span><span class="s0">{</span><span class="s1">str</span><span class="s2">(</span><span class="s1">non_method_attrs</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">:-</span><span class="s5">1</span><span class="s2">]</span><span class="s0">}</span><span class="s4">.&quot;</span>
                    <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">abc</span><span class="s2">.</span><span class="s1">ABCMeta</span><span class="s2">.</span><span class="s1">__subclasscheck__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__instancecheck__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">):</span>
            <span class="s3"># We need this method for situations where attributes are</span>
            <span class="s3"># assigned in __init__.</span>
            <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Protocol</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">type</span><span class="s2">.</span><span class="s1">__instancecheck__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s4">&quot;_is_protocol&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
                <span class="s3"># i.e., it's a concrete subclass of a protocol</span>
                <span class="s0">return </span><span class="s1">abc</span><span class="s2">.</span><span class="s1">ABCMeta</span><span class="s2">.</span><span class="s1">__instancecheck__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s2">(</span>
                <span class="s0">not </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s4">'_is_runtime_protocol'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">) </span><span class="s0">and</span>
                <span class="s0">not </span><span class="s1">_allow_reckless_class_checks</span><span class="s2">()</span>
            <span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Instance and class checks can only be used with&quot;</span>
                                <span class="s4">&quot; @runtime_checkable protocols&quot;</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">abc</span><span class="s2">.</span><span class="s1">ABCMeta</span><span class="s2">.</span><span class="s1">__instancecheck__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">):</span>
                <span class="s0">return True</span>

            <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__protocol_attrs__</span><span class="s2">:</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">val </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">getattr_static</span><span class="s2">(</span><span class="s1">instance</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
                    <span class="s0">break</span>
                <span class="s3"># this attribute is set by @runtime_checkable:</span>
                <span class="s0">if </span><span class="s1">val </span><span class="s0">is None and </span><span class="s1">attr </span><span class="s0">not in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__non_callable_proto_members__</span><span class="s2">:</span>
                    <span class="s0">break</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return True</span>

            <span class="s0">return False</span>

        <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3"># Hack so that typing.Generic.__class_getitem__</span>
            <span class="s3"># treats typing_extensions.Protocol</span>
            <span class="s3"># as equivalent to typing.Protocol</span>
            <span class="s0">if </span><span class="s1">abc</span><span class="s2">.</span><span class="s1">ABCMeta</span><span class="s2">.</span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">other</span><span class="s2">) </span><span class="s0">is True</span><span class="s2">:</span>
                <span class="s0">return True</span>
            <span class="s0">return </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Protocol </span><span class="s0">and </span><span class="s1">other </span><span class="s0">is </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Protocol</span>

        <span class="s3"># This has to be defined, or the abc-module cache</span>
        <span class="s3"># complains about classes with this metaclass being unhashable,</span>
        <span class="s3"># if we define only __eq__!</span>
        <span class="s0">def </span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">type</span><span class="s2">.</span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">_proto_hook</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'_is_protocol'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__protocol_attrs__</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__mro__</span><span class="s2">:</span>
                <span class="s3"># Check if the members appears in the class dictionary...</span>
                <span class="s0">if </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">base</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">base</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">[</span><span class="s1">attr</span><span class="s2">] </span><span class="s0">is None</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">NotImplemented</span>
                    <span class="s0">break</span>

                <span class="s3"># ...or in annotations, if it is a sub-protocol.</span>
                <span class="s1">annotations </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">base</span><span class="s2">, </span><span class="s4">'__annotations__'</span><span class="s2">, {})</span>
                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">annotations</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Mapping</span><span class="s2">)</span>
                    <span class="s0">and </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">annotations</span>
                    <span class="s0">and </span><span class="s1">is_protocol</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
                <span class="s2">):</span>
                    <span class="s0">break</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
        <span class="s0">return True</span>

    <span class="s0">class </span><span class="s1">Protocol</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span><span class="s2">, </span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">_ProtocolMeta</span><span class="s2">):</span>
        <span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Protocol</span><span class="s2">.</span><span class="s1">__doc__</span>
        <span class="s1">__slots__ </span><span class="s2">= ()</span>
        <span class="s1">_is_protocol </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s1">_is_runtime_protocol </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">def </span><span class="s1">__init_subclass__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">__init_subclass__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s3"># Determine if this is a protocol or a concrete subclass.</span>
            <span class="s0">if not </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'_is_protocol'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
                <span class="s1">cls</span><span class="s2">.</span><span class="s1">_is_protocol </span><span class="s2">= </span><span class="s1">any</span><span class="s2">(</span><span class="s1">b </span><span class="s0">is </span><span class="s1">Protocol </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__bases__</span><span class="s2">)</span>

            <span class="s3"># Set (or override) the protocol subclass hook.</span>
            <span class="s0">if </span><span class="s4">'__subclasshook__' </span><span class="s0">not in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">:</span>
                <span class="s1">cls</span><span class="s2">.</span><span class="s1">__subclasshook__ </span><span class="s2">= </span><span class="s1">_proto_hook</span>

            <span class="s3"># Prohibit instantiation for protocol classes</span>
            <span class="s0">if </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_is_protocol </span><span class="s0">and </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__init__ </span><span class="s0">is </span><span class="s1">Protocol</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">:</span>
                <span class="s1">cls</span><span class="s2">.</span><span class="s1">__init__ </span><span class="s2">= </span><span class="s1">_no_init</span>


<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">13</span><span class="s2">):</span>
    <span class="s1">runtime_checkable </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">runtime_checkable</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">runtime_checkable</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Mark a protocol class as a runtime protocol. 
 
        Such protocol can be used with isinstance() and issubclass(). 
        Raise TypeError if applied to a non-protocol class. 
        This allows a simple-minded structural check very similar to 
        one trick ponies in collections.abc such as Iterable. 
 
        For example:: 
 
            @runtime_checkable 
            class Closable(Protocol): 
                def close(self): ... 
 
            assert isinstance(open('/some/file'), Closable) 
 
        Warning: this will check only the presence of the required methods, 
        not their type signatures! 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span><span class="s2">) </span><span class="s0">or not </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s4">'_is_protocol'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f'@runtime_checkable can be only applied to protocol classes,'</span>
                            <span class="s4">f' got </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">!r}</span><span class="s4">'</span><span class="s2">)</span>
        <span class="s1">cls</span><span class="s2">.</span><span class="s1">_is_runtime_protocol </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s3"># typing.Protocol classes on &lt;=3.11 break if we execute this block,</span>
        <span class="s3"># because typing.Protocol classes on &lt;=3.11 don't have a</span>
        <span class="s3"># `__protocol_attrs__` attribute, and this block relies on the</span>
        <span class="s3"># `__protocol_attrs__` attribute. Meanwhile, typing.Protocol classes on 3.12.2+</span>
        <span class="s3"># break if we *don't* execute this block, because *they* assume that all</span>
        <span class="s3"># protocol classes have a `__non_callable_proto_members__` attribute</span>
        <span class="s3"># (which this block sets)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">_ProtocolMeta</span><span class="s2">) </span><span class="s0">or </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">2</span><span class="s2">):</span>
            <span class="s3"># PEP 544 prohibits using issubclass()</span>
            <span class="s3"># with protocols that have non-method members.</span>
            <span class="s3"># See gh-113320 for why we compute this attribute here,</span>
            <span class="s3"># rather than in `_ProtocolMeta.__init__`</span>
            <span class="s1">cls</span><span class="s2">.</span><span class="s1">__non_callable_proto_members__ </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
            <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__protocol_attrs__</span><span class="s2">:</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">is_callable </span><span class="s2">= </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s0">None</span><span class="s2">))</span>
                <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                        <span class="s4">f&quot;Failed to determine whether protocol member </span><span class="s0">{</span><span class="s1">attr</span><span class="s0">!r} </span><span class="s4">&quot;</span>
                        <span class="s4">&quot;is a method member&quot;</span>
                    <span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">if not </span><span class="s1">is_callable</span><span class="s2">:</span>
                        <span class="s1">cls</span><span class="s2">.</span><span class="s1">__non_callable_proto_members__</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">cls</span>


<span class="s3"># The &quot;runtime&quot; alias exists for backwards compatibility.</span>
<span class="s1">runtime </span><span class="s2">= </span><span class="s1">runtime_checkable</span>


<span class="s3"># Our version of runtime-checkable protocols is faster on Python 3.8-3.11</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">):</span>
    <span class="s1">SupportsInt </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">SupportsInt</span>
    <span class="s1">SupportsFloat </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">SupportsFloat</span>
    <span class="s1">SupportsComplex </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">SupportsComplex</span>
    <span class="s1">SupportsBytes </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">SupportsBytes</span>
    <span class="s1">SupportsIndex </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">SupportsIndex</span>
    <span class="s1">SupportsAbs </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">SupportsAbs</span>
    <span class="s1">SupportsRound </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">SupportsRound</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s2">@</span><span class="s1">runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsInt</span><span class="s2">(</span><span class="s1">Protocol</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;An ABC with one abstract method __int__.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
        <span class="s0">def </span><span class="s1">__int__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
            <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsFloat</span><span class="s2">(</span><span class="s1">Protocol</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;An ABC with one abstract method __float__.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
        <span class="s0">def </span><span class="s1">__float__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; float</span><span class="s2">:</span>
            <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsComplex</span><span class="s2">(</span><span class="s1">Protocol</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;An ABC with one abstract method __complex__.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
        <span class="s0">def </span><span class="s1">__complex__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; complex</span><span class="s2">:</span>
            <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsBytes</span><span class="s2">(</span><span class="s1">Protocol</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;An ABC with one abstract method __bytes__.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
        <span class="s0">def </span><span class="s1">__bytes__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bytes</span><span class="s2">:</span>
            <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsIndex</span><span class="s2">(</span><span class="s1">Protocol</span><span class="s2">):</span>
        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
        <span class="s0">def </span><span class="s1">__index__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
            <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsAbs</span><span class="s2">(</span><span class="s1">Protocol</span><span class="s2">[</span><span class="s1">T_co</span><span class="s2">]):</span>
        <span class="s6">&quot;&quot;&quot; 
        An ABC with one abstract method __abs__ that is covariant in its return type. 
        &quot;&quot;&quot;</span>
        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
        <span class="s0">def </span><span class="s1">__abs__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; T_co</span><span class="s2">:</span>
            <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsRound</span><span class="s2">(</span><span class="s1">Protocol</span><span class="s2">[</span><span class="s1">T_co</span><span class="s2">]):</span>
        <span class="s6">&quot;&quot;&quot; 
        An ABC with one abstract method __round__ that is covariant in its return type. 
        &quot;&quot;&quot;</span>
        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s2">@</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">abstractmethod</span>
        <span class="s0">def </span><span class="s1">__round__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ndigits</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s5">0</span><span class="s2">) </span><span class="s1">-&gt; T_co</span><span class="s2">:</span>
            <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">_ensure_subclassable</span><span class="s2">(</span><span class="s1">mro_entries</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">inner</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">implementation</span><span class="s2">.</span><span class="s1">name </span><span class="s2">== </span><span class="s4">&quot;pypy&quot; </span><span class="s0">and </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
            <span class="s1">cls_dict </span><span class="s2">= {</span>
                <span class="s4">&quot;__call__&quot;</span><span class="s2">: </span><span class="s1">staticmethod</span><span class="s2">(</span><span class="s1">func</span><span class="s2">),</span>
                <span class="s4">&quot;__mro_entries__&quot;</span><span class="s2">: </span><span class="s1">staticmethod</span><span class="s2">(</span><span class="s1">mro_entries</span><span class="s2">)</span>
            <span class="s2">}</span>
            <span class="s1">t </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">func</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, (), </span><span class="s1">cls_dict</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">update_wrapper</span><span class="s2">(</span><span class="s1">t</span><span class="s2">(), </span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">func</span><span class="s2">.</span><span class="s1">__mro_entries__ </span><span class="s2">= </span><span class="s1">mro_entries</span>
            <span class="s0">return </span><span class="s1">func</span>
    <span class="s0">return </span><span class="s1">inner</span>


<span class="s1">_NEEDS_SINGLETONMETA </span><span class="s2">= (</span>
    <span class="s0">not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;NoDefault&quot;</span><span class="s2">) </span><span class="s0">or not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;NoExtraItems&quot;</span><span class="s2">)</span>
<span class="s2">)</span>

<span class="s0">if </span><span class="s1">_NEEDS_SINGLETONMETA</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">SingletonMeta</span><span class="s2">(</span><span class="s1">type</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
            <span class="s3"># TypeError is consistent with the behavior of NoneType</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s4">f&quot;cannot set </span><span class="s0">{</span><span class="s1">attr</span><span class="s0">!r} </span><span class="s4">attribute of immutable type </span><span class="s0">{</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">!r}</span><span class="s4">&quot;</span>
            <span class="s2">)</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;NoDefault&quot;</span><span class="s2">):</span>
    <span class="s1">NoDefault </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">NoDefault</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">NoDefaultType</span><span class="s2">(</span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">SingletonMeta</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;The type of the NoDefault singleton.&quot;&quot;&quot;</span>

        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">globals</span><span class="s2">().</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;NoDefault&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">&quot;typing_extensions.NoDefault&quot;</span>

        <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">&quot;NoDefault&quot;</span>

    <span class="s1">NoDefault </span><span class="s2">= </span><span class="s1">NoDefaultType</span><span class="s2">()</span>
    <span class="s0">del </span><span class="s1">NoDefaultType</span>

<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;NoExtraItems&quot;</span><span class="s2">):</span>
    <span class="s1">NoExtraItems </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">NoExtraItems</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">NoExtraItemsType</span><span class="s2">(</span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">SingletonMeta</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;The type of the NoExtraItems singleton.&quot;&quot;&quot;</span>

        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">globals</span><span class="s2">().</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;NoExtraItems&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">&quot;typing_extensions.NoExtraItems&quot;</span>

        <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">&quot;NoExtraItems&quot;</span>

    <span class="s1">NoExtraItems </span><span class="s2">= </span><span class="s1">NoExtraItemsType</span><span class="s2">()</span>
    <span class="s0">del </span><span class="s1">NoExtraItemsType</span>

<span class="s0">if </span><span class="s1">_NEEDS_SINGLETONMETA</span><span class="s2">:</span>
    <span class="s0">del </span><span class="s1">SingletonMeta</span>


<span class="s3"># Update this to something like &gt;=3.13.0b1 if and when</span>
<span class="s3"># PEP 728 is implemented in CPython</span>
<span class="s1">_PEP_728_IMPLEMENTED </span><span class="s2">= </span><span class="s0">False</span>

<span class="s0">if </span><span class="s1">_PEP_728_IMPLEMENTED</span><span class="s2">:</span>
    <span class="s3"># The standard library TypedDict in Python 3.8 does not store runtime information</span>
    <span class="s3"># about which (if any) keys are optional.  See https://bugs.python.org/issue38834</span>
    <span class="s3"># The standard library TypedDict in Python 3.9.0/1 does not honour the &quot;total&quot;</span>
    <span class="s3"># keyword with old-style TypedDict().  See https://bugs.python.org/issue42059</span>
    <span class="s3"># The standard library TypedDict below Python 3.11 does not store runtime</span>
    <span class="s3"># information about optional and required keys when using Required or NotRequired.</span>
    <span class="s3"># Generic TypedDicts are also impossible using typing.TypedDict on Python &lt;3.11.</span>
    <span class="s3"># Aaaand on 3.12 we add __orig_bases__ to TypedDict</span>
    <span class="s3"># to enable better runtime introspection.</span>
    <span class="s3"># On 3.13 we deprecate some odd ways of creating TypedDicts.</span>
    <span class="s3"># Also on 3.13, PEP 705 adds the ReadOnly[] qualifier.</span>
    <span class="s3"># PEP 728 (still pending) makes more changes.</span>
    <span class="s1">TypedDict </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypedDict</span>
    <span class="s1">_TypedDictMeta </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_TypedDictMeta</span>
    <span class="s1">is_typeddict </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">is_typeddict</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s3"># 3.10.0 and later</span>
    <span class="s1">_TAKES_MODULE </span><span class="s2">= </span><span class="s4">&quot;module&quot; </span><span class="s0">in </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">).</span><span class="s1">parameters</span>

    <span class="s0">def </span><span class="s1">_get_typeddict_qualifiers</span><span class="s2">(</span><span class="s1">annotation_type</span><span class="s2">):</span>
        <span class="s0">while True</span><span class="s2">:</span>
            <span class="s1">annotation_origin </span><span class="s2">= </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">annotation_type</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">annotation_origin </span><span class="s0">is </span><span class="s1">Annotated</span><span class="s2">:</span>
                <span class="s1">annotation_args </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">annotation_type</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">annotation_args</span><span class="s2">:</span>
                    <span class="s1">annotation_type </span><span class="s2">= </span><span class="s1">annotation_args</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">break</span>
            <span class="s0">elif </span><span class="s1">annotation_origin </span><span class="s0">is </span><span class="s1">Required</span><span class="s2">:</span>
                <span class="s0">yield </span><span class="s1">Required</span>
                <span class="s1">annotation_type</span><span class="s2">, = </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">annotation_type</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">annotation_origin </span><span class="s0">is </span><span class="s1">NotRequired</span><span class="s2">:</span>
                <span class="s0">yield </span><span class="s1">NotRequired</span>
                <span class="s1">annotation_type</span><span class="s2">, = </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">annotation_type</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">annotation_origin </span><span class="s0">is </span><span class="s1">ReadOnly</span><span class="s2">:</span>
                <span class="s0">yield </span><span class="s1">ReadOnly</span>
                <span class="s1">annotation_type</span><span class="s2">, = </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">annotation_type</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">break</span>

    <span class="s0">class </span><span class="s1">_TypedDictMeta</span><span class="s2">(</span><span class="s1">type</span><span class="s2">):</span>

        <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">, </span><span class="s1">ns</span><span class="s2">, *, </span><span class="s1">total</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                    <span class="s1">extra_items</span><span class="s2">=</span><span class="s1">NoExtraItems</span><span class="s2">):</span>
            <span class="s6">&quot;&quot;&quot;Create new typed dict class object. 
 
            This method is called when TypedDict is subclassed, 
            or when TypedDict is instantiated. This way 
            TypedDict supports all three syntax forms described in its docstring. 
            Subclasses and instances of TypedDict return actual dictionaries. 
            &quot;&quot;&quot;</span>
            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">base</span><span class="s2">) </span><span class="s0">is not </span><span class="s1">_TypedDictMeta </span><span class="s0">and </span><span class="s1">base </span><span class="s0">is not </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">'cannot inherit from both a TypedDict type '</span>
                                    <span class="s4">'and a non-TypedDict base class'</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">closed </span><span class="s0">is not None and </span><span class="s1">extra_items </span><span class="s0">is not </span><span class="s1">NoExtraItems</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Cannot combine closed=</span><span class="s0">{</span><span class="s1">closed</span><span class="s0">!r} </span><span class="s4">and extra_items&quot;</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span><span class="s2">) </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bases</span><span class="s2">):</span>
                <span class="s1">generic_base </span><span class="s2">= (</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span><span class="s2">,)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">generic_base </span><span class="s2">= ()</span>

            <span class="s3"># typing.py generally doesn't let you inherit from plain Generic, unless</span>
            <span class="s3"># the name of the class happens to be &quot;Protocol&quot;</span>
            <span class="s1">tp_dict </span><span class="s2">= </span><span class="s1">type</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">_TypedDictMeta</span><span class="s2">, </span><span class="s4">&quot;Protocol&quot;</span><span class="s2">, (*</span><span class="s1">generic_base</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">), </span><span class="s1">ns</span><span class="s2">)</span>
            <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s1">name</span>
            <span class="s0">if </span><span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__qualname__ </span><span class="s2">== </span><span class="s4">&quot;Protocol&quot;</span><span class="s2">:</span>
                <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__qualname__ </span><span class="s2">= </span><span class="s1">name</span>

            <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">tp_dict</span><span class="s2">, </span><span class="s4">'__orig_bases__'</span><span class="s2">):</span>
                <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__orig_bases__ </span><span class="s2">= </span><span class="s1">bases</span>

            <span class="s1">annotations </span><span class="s2">= {}</span>
            <span class="s0">if </span><span class="s4">&quot;__annotations__&quot; </span><span class="s0">in </span><span class="s1">ns</span><span class="s2">:</span>
                <span class="s1">own_annotations </span><span class="s2">= </span><span class="s1">ns</span><span class="s2">[</span><span class="s4">&quot;__annotations__&quot;</span><span class="s2">]</span>
            <span class="s0">elif </span><span class="s4">&quot;__annotate__&quot; </span><span class="s0">in </span><span class="s1">ns</span><span class="s2">:</span>
                <span class="s3"># TODO: Use inspect.VALUE here, and make the annotations lazily evaluated</span>
                <span class="s1">own_annotations </span><span class="s2">= </span><span class="s1">ns</span><span class="s2">[</span><span class="s4">&quot;__annotate__&quot;</span><span class="s2">](</span><span class="s5">1</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">own_annotations </span><span class="s2">= {}</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type&quot;</span>
            <span class="s0">if </span><span class="s1">_TAKES_MODULE</span><span class="s2">:</span>
                <span class="s1">own_annotations </span><span class="s2">= {</span>
                    <span class="s1">n</span><span class="s2">: </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">module</span><span class="s2">=</span><span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__module__</span><span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">own_annotations</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                <span class="s2">}</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">own_annotations </span><span class="s2">= {</span>
                    <span class="s1">n</span><span class="s2">: </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">own_annotations</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                <span class="s2">}</span>
            <span class="s1">required_keys </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
            <span class="s1">optional_keys </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
            <span class="s1">readonly_keys </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
            <span class="s1">mutable_keys </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
            <span class="s1">extra_items_type </span><span class="s2">= </span><span class="s1">extra_items</span>

            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases</span><span class="s2">:</span>
                <span class="s1">base_dict </span><span class="s2">= </span><span class="s1">base</span><span class="s2">.</span><span class="s1">__dict__</span>

                <span class="s1">annotations</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">base_dict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'__annotations__'</span><span class="s2">, {}))</span>
                <span class="s1">required_keys</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">base_dict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'__required_keys__'</span><span class="s2">, ()))</span>
                <span class="s1">optional_keys</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">base_dict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'__optional_keys__'</span><span class="s2">, ()))</span>
                <span class="s1">readonly_keys</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">base_dict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'__readonly_keys__'</span><span class="s2">, ()))</span>
                <span class="s1">mutable_keys</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">base_dict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'__mutable_keys__'</span><span class="s2">, ()))</span>

            <span class="s3"># This was specified in an earlier version of PEP 728. Support</span>
            <span class="s3"># is retained for backwards compatibility, but only for Python</span>
            <span class="s3"># 3.13 and lower.</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s1">closed </span><span class="s0">and </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">14</span><span class="s2">)</span>
                       <span class="s0">and </span><span class="s4">&quot;__extra_items__&quot; </span><span class="s0">in </span><span class="s1">own_annotations</span><span class="s2">):</span>
                <span class="s1">annotation_type </span><span class="s2">= </span><span class="s1">own_annotations</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s4">&quot;__extra_items__&quot;</span><span class="s2">)</span>
                <span class="s1">qualifiers </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">_get_typeddict_qualifiers</span><span class="s2">(</span><span class="s1">annotation_type</span><span class="s2">))</span>
                <span class="s0">if </span><span class="s1">Required </span><span class="s0">in </span><span class="s1">qualifiers</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                        <span class="s4">&quot;Special key __extra_items__ does not support &quot;</span>
                        <span class="s4">&quot;Required&quot;</span>
                    <span class="s2">)</span>
                <span class="s0">if </span><span class="s1">NotRequired </span><span class="s0">in </span><span class="s1">qualifiers</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                        <span class="s4">&quot;Special key __extra_items__ does not support &quot;</span>
                        <span class="s4">&quot;NotRequired&quot;</span>
                    <span class="s2">)</span>
                <span class="s1">extra_items_type </span><span class="s2">= </span><span class="s1">annotation_type</span>

            <span class="s1">annotations</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">own_annotations</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">annotation_key</span><span class="s2">, </span><span class="s1">annotation_type </span><span class="s0">in </span><span class="s1">own_annotations</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s1">qualifiers </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">_get_typeddict_qualifiers</span><span class="s2">(</span><span class="s1">annotation_type</span><span class="s2">))</span>

                <span class="s0">if </span><span class="s1">Required </span><span class="s0">in </span><span class="s1">qualifiers</span><span class="s2">:</span>
                    <span class="s1">required_keys</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">annotation_key</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">NotRequired </span><span class="s0">in </span><span class="s1">qualifiers</span><span class="s2">:</span>
                    <span class="s1">optional_keys</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">annotation_key</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">total</span><span class="s2">:</span>
                    <span class="s1">required_keys</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">annotation_key</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">optional_keys</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">annotation_key</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">ReadOnly </span><span class="s0">in </span><span class="s1">qualifiers</span><span class="s2">:</span>
                    <span class="s1">mutable_keys</span><span class="s2">.</span><span class="s1">discard</span><span class="s2">(</span><span class="s1">annotation_key</span><span class="s2">)</span>
                    <span class="s1">readonly_keys</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">annotation_key</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">mutable_keys</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">annotation_key</span><span class="s2">)</span>
                    <span class="s1">readonly_keys</span><span class="s2">.</span><span class="s1">discard</span><span class="s2">(</span><span class="s1">annotation_key</span><span class="s2">)</span>

            <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__annotations__ </span><span class="s2">= </span><span class="s1">annotations</span>
            <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__required_keys__ </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">required_keys</span><span class="s2">)</span>
            <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__optional_keys__ </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">optional_keys</span><span class="s2">)</span>
            <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__readonly_keys__ </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">readonly_keys</span><span class="s2">)</span>
            <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__mutable_keys__ </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">mutable_keys</span><span class="s2">)</span>
            <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__total__ </span><span class="s2">= </span><span class="s1">total</span>
            <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__closed__ </span><span class="s2">= </span><span class="s1">closed</span>
            <span class="s1">tp_dict</span><span class="s2">.</span><span class="s1">__extra_items__ </span><span class="s2">= </span><span class="s1">extra_items_type</span>
            <span class="s0">return </span><span class="s1">tp_dict</span>

        <span class="s1">__call__ </span><span class="s2">= </span><span class="s1">dict  </span><span class="s3"># static method</span>

        <span class="s0">def </span><span class="s1">__subclasscheck__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3"># Typed dicts are only for static structural subtyping.</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">'TypedDict does not support instance and class checks'</span><span class="s2">)</span>

        <span class="s1">__instancecheck__ </span><span class="s2">= </span><span class="s1">__subclasscheck__</span>

    <span class="s1">_TypedDict </span><span class="s2">= </span><span class="s1">type</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">_TypedDictMeta</span><span class="s2">, </span><span class="s4">'TypedDict'</span><span class="s2">, (), {})</span>

    <span class="s2">@</span><span class="s1">_ensure_subclassable</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">bases</span><span class="s2">: (</span><span class="s1">_TypedDict</span><span class="s2">,))</span>
    <span class="s0">def </span><span class="s1">TypedDict</span><span class="s2">(</span>
        <span class="s1">typename</span><span class="s2">,</span>
        <span class="s1">fields</span><span class="s2">=</span><span class="s1">_marker</span><span class="s2">,</span>
        <span class="s2">/,</span>
        <span class="s2">*,</span>
        <span class="s1">total</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">closed</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">extra_items</span><span class="s2">=</span><span class="s1">NoExtraItems</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span>
    <span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;A simple typed namespace. At runtime it is equivalent to a plain dict. 
 
        TypedDict creates a dictionary type such that a type checker will expect all 
        instances to have a certain set of keys, where each key is 
        associated with a value of a consistent type. This expectation 
        is not checked at runtime. 
 
        Usage:: 
 
            class Point2D(TypedDict): 
                x: int 
                y: int 
                label: str 
 
            a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK 
            b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check 
 
            assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first') 
 
        The type info can be accessed via the Point2D.__annotations__ dict, and 
        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets. 
        TypedDict supports an additional equivalent form:: 
 
            Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str}) 
 
        By default, all keys must be present in a TypedDict. It is possible 
        to override this by specifying totality:: 
 
            class Point2D(TypedDict, total=False): 
                x: int 
                y: int 
 
        This means that a Point2D TypedDict can have any of the keys omitted. A type 
        checker is only expected to support a literal False or True as the value of 
        the total argument. True is the default, and makes all items defined in the 
        class body be required. 
 
        The Required and NotRequired special forms can also be used to mark 
        individual keys as being required or not required:: 
 
            class Point2D(TypedDict): 
                x: int  # the &quot;x&quot; key must always be present (Required is the default) 
                y: NotRequired[int]  # the &quot;y&quot; key can be omitted 
 
        See PEP 655 for more details on Required and NotRequired. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">fields </span><span class="s0">is </span><span class="s1">_marker </span><span class="s0">or </span><span class="s1">fields </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">fields </span><span class="s0">is </span><span class="s1">_marker</span><span class="s2">:</span>
                <span class="s1">deprecated_thing </span><span class="s2">= </span><span class="s4">&quot;Failing to pass a value for the 'fields' parameter&quot;</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">deprecated_thing </span><span class="s2">= </span><span class="s4">&quot;Passing `None` as the 'fields' parameter&quot;</span>

            <span class="s1">example </span><span class="s2">= </span><span class="s4">f&quot;`</span><span class="s0">{</span><span class="s1">typename</span><span class="s0">} </span><span class="s4">= TypedDict(</span><span class="s0">{</span><span class="s1">typename</span><span class="s0">!r}</span><span class="s4">, </span><span class="s0">{{}}</span><span class="s4">)`&quot;</span>
            <span class="s1">deprecation_msg </span><span class="s2">= (</span>
                <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">deprecated_thing</span><span class="s0">} </span><span class="s4">is deprecated and will be disallowed in &quot;</span>
                <span class="s4">&quot;Python 3.15. To create a TypedDict class with 0 fields &quot;</span>
                <span class="s4">&quot;using the functional syntax, pass an empty dictionary, e.g. &quot;</span>
            <span class="s2">) + </span><span class="s1">example </span><span class="s2">+ </span><span class="s4">&quot;.&quot;</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">deprecation_msg</span><span class="s2">, </span><span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
            <span class="s3"># Support a field called &quot;closed&quot;</span>
            <span class="s0">if </span><span class="s1">closed </span><span class="s0">is not False and </span><span class="s1">closed </span><span class="s0">is not True and </span><span class="s1">closed </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">kwargs</span><span class="s2">[</span><span class="s4">&quot;closed&quot;</span><span class="s2">] = </span><span class="s1">closed</span>
                <span class="s1">closed </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s3"># Or &quot;extra_items&quot;</span>
            <span class="s0">if </span><span class="s1">extra_items </span><span class="s0">is not </span><span class="s1">NoExtraItems</span><span class="s2">:</span>
                <span class="s1">kwargs</span><span class="s2">[</span><span class="s4">&quot;extra_items&quot;</span><span class="s2">] = </span><span class="s1">extra_items</span>
                <span class="s1">extra_items </span><span class="s2">= </span><span class="s1">NoExtraItems</span>
            <span class="s1">fields </span><span class="s2">= </span><span class="s1">kwargs</span>
        <span class="s0">elif </span><span class="s1">kwargs</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;TypedDict takes either a dict or keyword arguments,&quot;</span>
                            <span class="s4">&quot; but not both&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">kwargs</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">13</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;TypedDict takes no keyword arguments&quot;</span><span class="s2">)</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s4">&quot;The kwargs-based syntax for TypedDict definitions is deprecated &quot;</span>
                <span class="s4">&quot;in Python 3.11, will be removed in Python 3.13, and may not be &quot;</span>
                <span class="s4">&quot;understood by third-party type checkers.&quot;</span><span class="s2">,</span>
                <span class="s1">DeprecationWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s1">ns </span><span class="s2">= {</span><span class="s4">'__annotations__'</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">fields</span><span class="s2">)}</span>
        <span class="s1">module </span><span class="s2">= </span><span class="s1">_caller</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">module </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s3"># Setting correct module is necessary to make typed dict classes pickleable.</span>
            <span class="s1">ns</span><span class="s2">[</span><span class="s4">'__module__'</span><span class="s2">] = </span><span class="s1">module</span>

        <span class="s1">td </span><span class="s2">= </span><span class="s1">_TypedDictMeta</span><span class="s2">(</span><span class="s1">typename</span><span class="s2">, (), </span><span class="s1">ns</span><span class="s2">, </span><span class="s1">total</span><span class="s2">=</span><span class="s1">total</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">=</span><span class="s1">closed</span><span class="s2">,</span>
                            <span class="s1">extra_items</span><span class="s2">=</span><span class="s1">extra_items</span><span class="s2">)</span>
        <span class="s1">td</span><span class="s2">.</span><span class="s1">__orig_bases__ </span><span class="s2">= (</span><span class="s1">TypedDict</span><span class="s2">,)</span>
        <span class="s0">return </span><span class="s1">td</span>

    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;_TypedDictMeta&quot;</span><span class="s2">):</span>
        <span class="s1">_TYPEDDICT_TYPES </span><span class="s2">= (</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_TypedDictMeta</span><span class="s2">, </span><span class="s1">_TypedDictMeta</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">_TYPEDDICT_TYPES </span><span class="s2">= (</span><span class="s1">_TypedDictMeta</span><span class="s2">,)</span>

    <span class="s0">def </span><span class="s1">is_typeddict</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Check if an annotation is a TypedDict class 
 
        For example:: 
            class Film(TypedDict): 
                title: str 
                year: int 
 
            is_typeddict(Film)  # =&gt; True 
            is_typeddict(Union[list, str])  # =&gt; False 
        &quot;&quot;&quot;</span>
        <span class="s3"># On 3.8, this would otherwise return True</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;TypedDict&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">tp </span><span class="s0">is </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypedDict</span><span class="s2">:</span>
            <span class="s0">return False</span>
        <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">_TYPEDDICT_TYPES</span><span class="s2">)</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;assert_type&quot;</span><span class="s2">):</span>
    <span class="s1">assert_type </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">assert_type</span>

<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">assert_type</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">typ</span><span class="s2">, /):</span>
        <span class="s6">&quot;&quot;&quot;Assert (to the type checker) that the value is of the given type. 
 
        When the type checker encounters a call to assert_type(), it 
        emits an error if the value is not of the specified type:: 
 
            def greet(name: str) -&gt; None: 
                assert_type(name, str)  # ok 
                assert_type(name, int)  # type checker error 
 
        At runtime this returns the first argument unchanged and otherwise 
        does nothing. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">val</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;ReadOnly&quot;</span><span class="s2">):  </span><span class="s3"># 3.13+</span>
    <span class="s1">get_type_hints </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">get_type_hints</span>
<span class="s0">else</span><span class="s2">:  </span><span class="s3"># &lt;=3.13</span>
    <span class="s3"># replaces _strip_annotations()</span>
    <span class="s0">def </span><span class="s1">_strip_extras</span><span class="s2">(</span><span class="s1">t</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Strips Annotated, Required and NotRequired from a given type.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">_AnnotatedAlias</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">_strip_extras</span><span class="s2">(</span><span class="s1">t</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s4">&quot;__origin__&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">t</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s0">in </span><span class="s2">(</span><span class="s1">Required</span><span class="s2">, </span><span class="s1">NotRequired</span><span class="s2">, </span><span class="s1">ReadOnly</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">_strip_extras</span><span class="s2">(</span><span class="s1">t</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">):</span>
            <span class="s1">stripped_args </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">_strip_extras</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">t</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">stripped_args </span><span class="s2">== </span><span class="s1">t</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">t</span>
            <span class="s0">return </span><span class="s1">t</span><span class="s2">.</span><span class="s1">copy_with</span><span class="s2">(</span><span class="s1">stripped_args</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">_types</span><span class="s2">, </span><span class="s4">&quot;GenericAlias&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">):</span>
            <span class="s1">stripped_args </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">_strip_extras</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">t</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">stripped_args </span><span class="s2">== </span><span class="s1">t</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">t</span>
            <span class="s0">return </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">(</span><span class="s1">t</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">, </span><span class="s1">stripped_args</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">_types</span><span class="s2">, </span><span class="s4">&quot;UnionType&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">UnionType</span><span class="s2">):</span>
            <span class="s1">stripped_args </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">_strip_extras</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">t</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">stripped_args </span><span class="s2">== </span><span class="s1">t</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">t</span>
            <span class="s0">return </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">or_</span><span class="s2">, </span><span class="s1">stripped_args</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">t</span>

    <span class="s0">def </span><span class="s1">get_type_hints</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">globalns</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">localns</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">include_extras</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Return type hints for an object. 
 
        This is often the same as obj.__annotations__, but it handles 
        forward references encoded as string literals, adds Optional[t] if a 
        default value equal to None is set and recursively replaces all 
        'Annotated[T, ...]', 'Required[T]' or 'NotRequired[T]' with 'T' 
        (unless 'include_extras=True'). 
 
        The argument may be a module, class, method, or function. The annotations 
        are returned as a dictionary. For classes, annotations include also 
        inherited members. 
 
        TypeError is raised if the argument is not of a type that can contain 
        annotations, and an empty dictionary is returned if no annotations are 
        present. 
 
        BEWARE -- the behavior of globalns and localns is counterintuitive 
        (unless you are familiar with how eval() and exec() work).  The 
        search order is locals first, then globals. 
 
        - If no dict arguments are passed, an attempt is made to use the 
          globals from obj (or the respective module's globals for classes), 
          and these are also used as the locals.  If the object does not appear 
          to have globals, an empty dictionary is used. 
 
        - If one dict argument is passed, it is used for both globals and 
          locals. 
 
        - If two dict arguments are passed, they specify globals and 
          locals, respectively. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;Annotated&quot;</span><span class="s2">):  </span><span class="s3"># 3.9+</span>
            <span class="s1">hint </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">get_type_hints</span><span class="s2">(</span>
                <span class="s1">obj</span><span class="s2">, </span><span class="s1">globalns</span><span class="s2">=</span><span class="s1">globalns</span><span class="s2">, </span><span class="s1">localns</span><span class="s2">=</span><span class="s1">localns</span><span class="s2">, </span><span class="s1">include_extras</span><span class="s2">=</span><span class="s0">True</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:  </span><span class="s3"># 3.8</span>
            <span class="s1">hint </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">get_type_hints</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">globalns</span><span class="s2">=</span><span class="s1">globalns</span><span class="s2">, </span><span class="s1">localns</span><span class="s2">=</span><span class="s1">localns</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">11</span><span class="s2">):</span>
            <span class="s1">_clean_optional</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">hint</span><span class="s2">, </span><span class="s1">globalns</span><span class="s2">, </span><span class="s1">localns</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
            <span class="s3"># In 3.8 eval_type does not flatten Optional[ForwardRef] correctly</span>
            <span class="s3"># This will recreate and and cache Unions.</span>
            <span class="s1">hint </span><span class="s2">= {</span>
                <span class="s1">k</span><span class="s2">: (</span><span class="s1">t</span>
                    <span class="s0">if </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">t</span><span class="s2">) != </span><span class="s1">Union</span>
                    <span class="s0">else </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">])</span>
                <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">hint</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
            <span class="s2">}</span>
        <span class="s0">if </span><span class="s1">include_extras</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">hint</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s1">k</span><span class="s2">: </span><span class="s1">_strip_extras</span><span class="s2">(</span><span class="s1">t</span><span class="s2">) </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">hint</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()}</span>

    <span class="s1">_NoneType </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_could_be_inserted_optional</span><span class="s2">(</span><span class="s1">t</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;detects Union[..., None] pattern&quot;&quot;&quot;</span>
        <span class="s3"># 3.8+ compatible checking before _UnionGenericAlias</span>
        <span class="s0">if </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">t</span><span class="s2">) </span><span class="s0">is not </span><span class="s1">Union</span><span class="s2">:</span>
            <span class="s0">return False</span>
        <span class="s3"># Assume if last argument is not None they are user defined</span>
        <span class="s0">if </span><span class="s1">t</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] </span><span class="s0">is not </span><span class="s1">_NoneType</span><span class="s2">:</span>
            <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s3"># &lt; 3.11</span>
    <span class="s0">def </span><span class="s1">_clean_optional</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">hints</span><span class="s2">, </span><span class="s1">globalns</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">localns</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3"># reverts injected Union[..., None] cases from typing.get_type_hints</span>
        <span class="s3"># when a None default value is used.</span>
        <span class="s3"># see https://github.com/python/typing_extensions/issues/310</span>
        <span class="s0">if not </span><span class="s1">hints </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
            <span class="s0">return</span>
        <span class="s1">defaults </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_get_defaults</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)  </span><span class="s3"># avoid accessing __annotations___</span>
        <span class="s0">if not </span><span class="s1">defaults</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s1">original_hints </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">__annotations__</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">hints</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s3"># Not a Union[..., None] or replacement conditions not fullfilled</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s0">not </span><span class="s1">_could_be_inserted_optional</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
                <span class="s0">or </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">defaults</span>
                <span class="s0">or </span><span class="s1">defaults</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] </span><span class="s0">is not None</span>
            <span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">original_value </span><span class="s2">= </span><span class="s1">original_hints</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
            <span class="s3"># value=NoneType should have caused a skip above but check for safety</span>
            <span class="s0">if </span><span class="s1">original_value </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">original_value </span><span class="s2">= </span><span class="s1">_NoneType</span>
            <span class="s3"># Forward reference</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">original_value</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">globalns </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">ModuleType</span><span class="s2">):</span>
                        <span class="s1">globalns </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">__dict__</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s1">nsobj </span><span class="s2">= </span><span class="s1">obj</span>
                        <span class="s3"># Find globalns for the unwrapped object.</span>
                        <span class="s0">while </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">nsobj</span><span class="s2">, </span><span class="s4">'__wrapped__'</span><span class="s2">):</span>
                            <span class="s1">nsobj </span><span class="s2">= </span><span class="s1">nsobj</span><span class="s2">.</span><span class="s1">__wrapped__</span>
                        <span class="s1">globalns </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">nsobj</span><span class="s2">, </span><span class="s4">'__globals__'</span><span class="s2">, {})</span>
                    <span class="s0">if </span><span class="s1">localns </span><span class="s0">is None</span><span class="s2">:</span>
                        <span class="s1">localns </span><span class="s2">= </span><span class="s1">globalns</span>
                <span class="s0">elif </span><span class="s1">localns </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">localns </span><span class="s2">= </span><span class="s1">globalns</span>
                <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
                    <span class="s1">original_value </span><span class="s2">= </span><span class="s1">ForwardRef</span><span class="s2">(</span><span class="s1">original_value</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">original_value </span><span class="s2">= </span><span class="s1">ForwardRef</span><span class="s2">(</span>
                        <span class="s1">original_value</span><span class="s2">,</span>
                        <span class="s1">is_argument</span><span class="s2">=</span><span class="s0">not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">ModuleType</span><span class="s2">)</span>
                    <span class="s2">)</span>
            <span class="s1">original_evaluated </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_eval_type</span><span class="s2">(</span><span class="s1">original_value</span><span class="s2">, </span><span class="s1">globalns</span><span class="s2">, </span><span class="s1">localns</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">) </span><span class="s0">and </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">original_evaluated</span><span class="s2">) </span><span class="s0">is </span><span class="s1">Union</span><span class="s2">:</span>
                <span class="s3"># Union[str, None, &quot;str&quot;] is not reduced to Union[str, None]</span>
                <span class="s1">original_evaluated </span><span class="s2">= </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">original_evaluated</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">]</span>
            <span class="s3"># Compare if values differ. Note that even if equal</span>
            <span class="s3"># value might be cached by typing._tp_cache contrary to original_evaluated</span>
            <span class="s0">if </span><span class="s1">original_evaluated </span><span class="s2">!= </span><span class="s1">value </span><span class="s0">or </span><span class="s2">(</span>
                <span class="s3"># 3.10: ForwardRefs of UnionType might be turned into _UnionGenericAlias</span>
                <span class="s1">hasattr</span><span class="s2">(</span><span class="s1">_types</span><span class="s2">, </span><span class="s4">&quot;UnionType&quot;</span><span class="s2">)</span>
                <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">original_evaluated</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">UnionType</span><span class="s2">)</span>
                <span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">UnionType</span><span class="s2">)</span>
            <span class="s2">):</span>
                <span class="s1">hints</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">original_evaluated</span>

<span class="s3"># Python 3.9+ has PEP 593 (Annotated)</span>
<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'Annotated'</span><span class="s2">):</span>
    <span class="s1">Annotated </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Annotated</span>
    <span class="s3"># Not exported and not a public API, but needed for get_origin() and get_args()</span>
    <span class="s3"># to work.</span>
    <span class="s1">_AnnotatedAlias </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_AnnotatedAlias</span>
<span class="s3"># 3.8</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">_AnnotatedAlias</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Runtime representation of an annotated type. 
 
        At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't' 
        with extra annotations. The alias behaves like a normal typing alias, 
        instantiating is the same as instantiating the underlying type, binding 
        it to types is also the same. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">metadata</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">_AnnotatedAlias</span><span class="s2">):</span>
                <span class="s1">metadata </span><span class="s2">= </span><span class="s1">origin</span><span class="s2">.</span><span class="s1">__metadata__ </span><span class="s2">+ </span><span class="s1">metadata</span>
                <span class="s1">origin </span><span class="s2">= </span><span class="s1">origin</span><span class="s2">.</span><span class="s1">__origin__</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__metadata__ </span><span class="s2">= </span><span class="s1">metadata</span>

        <span class="s0">def </span><span class="s1">copy_with</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">):</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">) == </span><span class="s5">1</span>
            <span class="s1">new_type </span><span class="s2">= </span><span class="s1">params</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">_AnnotatedAlias</span><span class="s2">(</span><span class="s1">new_type</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__metadata__</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s4">f&quot;typing_extensions.Annotated[</span><span class="s0">{</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">)</span><span class="s0">}</span><span class="s4">, &quot;</span>
                    <span class="s4">f&quot;</span><span class="s0">{</span><span class="s4">', '</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__metadata__</span><span class="s2">)</span><span class="s0">}</span><span class="s4">]&quot;</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">getitem</span><span class="s2">, (</span>
                <span class="s1">Annotated</span><span class="s2">, (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__metadata__</span><span class="s2">)</span>
            <span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">_AnnotatedAlias</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s2">!= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">:</span>
                <span class="s0">return False</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__metadata__ </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__metadata__</span>

        <span class="s0">def </span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">hash</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__metadata__</span><span class="s2">))</span>

    <span class="s0">class </span><span class="s1">Annotated</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Add context specific metadata to a type. 
 
        Example: Annotated[int, runtime_check.Unsigned] indicates to the 
        hypothetical runtime_check module that this type is an unsigned int. 
        Every other consumer of this type can ignore this metadata and treat 
        this type as int. 
 
        The first argument to Annotated must be a valid type (and will be in 
        the __origin__ field), the remaining arguments are kept as a tuple in 
        the __extra__ field. 
 
        Details: 
 
        - It's an error to call `Annotated` with less than two arguments. 
        - Nested Annotated are flattened:: 
 
            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3] 
 
        - Instantiating an annotated type is equivalent to instantiating the 
        underlying type:: 
 
            Annotated[C, Ann1](5) == C(5) 
 
        - Annotated can be used as a generic type alias:: 
 
            Optimized = Annotated[T, runtime.Optimize()] 
            Optimized[int] == Annotated[int, runtime.Optimize()] 
 
            OptimizedList = Annotated[List[T], runtime.Optimize()] 
            OptimizedList[int] == Annotated[List[int], runtime.Optimize()] 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Type Annotated cannot be instantiated.&quot;</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_tp_cache</span>
        <span class="s0">def </span><span class="s1">__class_getitem__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">params</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">params</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">) &lt; </span><span class="s5">2</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Annotated[...] should be used &quot;</span>
                                <span class="s4">&quot;with at least two arguments (a type and an &quot;</span>
                                <span class="s4">&quot;annotation).&quot;</span><span class="s2">)</span>
            <span class="s1">allowed_special_forms </span><span class="s2">= (</span><span class="s1">ClassVar</span><span class="s2">, </span><span class="s1">Final</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">params</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]) </span><span class="s0">in </span><span class="s1">allowed_special_forms</span><span class="s2">:</span>
                <span class="s1">origin </span><span class="s2">= </span><span class="s1">params</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;Annotated[t, ...]: t must be a type.&quot;</span>
                <span class="s1">origin </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">params</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">msg</span><span class="s2">)</span>
            <span class="s1">metadata </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">params</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])</span>
            <span class="s0">return </span><span class="s1">_AnnotatedAlias</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">metadata</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__init_subclass__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s4">f&quot;Cannot subclass </span><span class="s0">{</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__module__</span><span class="s0">}</span><span class="s4">.Annotated&quot;</span>
            <span class="s2">)</span>

<span class="s3"># Python 3.8 has get_origin() and get_args() but those implementations aren't</span>
<span class="s3"># Annotated-aware, so we can't use those. Python 3.9's versions don't support</span>
<span class="s3"># ParamSpecArgs and ParamSpecKwargs, so only Python 3.10's versions will do.</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">] &gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">):</span>
    <span class="s1">get_origin </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">get_origin</span>
    <span class="s1">get_args </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">get_args</span>
<span class="s3"># 3.8-3.9</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s3"># 3.9+</span>
        <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">_BaseGenericAlias</span>
    <span class="s0">except </span><span class="s1">ImportError</span><span class="s2">:</span>
        <span class="s1">_BaseGenericAlias </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s3"># 3.9+</span>
        <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">GenericAlias </span><span class="s0">as </span><span class="s1">_typing_GenericAlias</span>
    <span class="s0">except </span><span class="s1">ImportError</span><span class="s2">:</span>
        <span class="s1">_typing_GenericAlias </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span>

    <span class="s0">def </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Get the unsubscripted version of a type. 
 
        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar 
        and Annotated. Return None for unsupported types. Examples:: 
 
            get_origin(Literal[42]) is Literal 
            get_origin(int) is None 
            get_origin(ClassVar[int]) is ClassVar 
            get_origin(Generic) is Generic 
            get_origin(Generic[T]) is Generic 
            get_origin(Union[T, int]) is Union 
            get_origin(List[Tuple[T, T]][int]) == list 
            get_origin(P.args) is P 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">_AnnotatedAlias</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">Annotated</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, (</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_typing_GenericAlias</span><span class="s2">, </span><span class="s1">_BaseGenericAlias</span><span class="s2">,</span>
                           <span class="s1">ParamSpecArgs</span><span class="s2">, </span><span class="s1">ParamSpecKwargs</span><span class="s2">)):</span>
            <span class="s0">return </span><span class="s1">tp</span><span class="s2">.</span><span class="s1">__origin__</span>
        <span class="s0">if </span><span class="s1">tp </span><span class="s0">is </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Get type arguments with all substitutions performed. 
 
        For unions, basic simplifications used by Union constructor are performed. 
        Examples:: 
            get_args(Dict[str, int]) == (str, int) 
            get_args(int) == () 
            get_args(Union[int, Union[T, int], str][int]) == (int, str) 
            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int]) 
            get_args(Callable[[], T][int]) == ([], int) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">_AnnotatedAlias</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s1">tp</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">, *</span><span class="s1">tp</span><span class="s2">.</span><span class="s1">__metadata__</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, (</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_typing_GenericAlias</span><span class="s2">)):</span>
            <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s4">&quot;_special&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s2">()</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">tp</span><span class="s2">.</span><span class="s1">__args__</span>
            <span class="s0">if </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">) </span><span class="s0">is </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Callable </span><span class="s0">and </span><span class="s1">res</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] </span><span class="s0">is not </span><span class="s1">Ellipsis</span><span class="s2">:</span>
                <span class="s1">res </span><span class="s2">= (</span><span class="s1">list</span><span class="s2">(</span><span class="s1">res</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">]), </span><span class="s1">res</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">])</span>
            <span class="s0">return </span><span class="s1">res</span>
        <span class="s0">return </span><span class="s2">()</span>


<span class="s3"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'TypeAlias'</span><span class="s2">):</span>
    <span class="s1">TypeAlias </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeAlias</span>
<span class="s3"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">] &gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">TypeAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Special marker indicating that an assignment should 
        be recognized as a proper type alias definition by type 
        checkers. 
 
        For example:: 
 
            Predicate: TypeAlias = Callable[..., bool] 
 
        It's invalid when used anywhere except as in the example above. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">is not subscriptable&quot;</span><span class="s2">)</span>
<span class="s3"># 3.8</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s1">TypeAlias </span><span class="s2">= </span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">(</span>
        <span class="s4">'TypeAlias'</span><span class="s2">,</span>
        <span class="s1">doc</span><span class="s2">=</span><span class="s4">&quot;&quot;&quot;Special marker indicating that an assignment should 
        be recognized as a proper type alias definition by type 
        checkers. 
 
        For example:: 
 
            Predicate: TypeAlias = Callable[..., bool] 
 
        It's invalid when used anywhere except as in the example 
        above.&quot;&quot;&quot;</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">_set_default</span><span class="s2">(</span><span class="s1">type_param</span><span class="s2">, </span><span class="s1">default</span><span class="s2">):</span>
    <span class="s1">type_param</span><span class="s2">.</span><span class="s1">has_default </span><span class="s2">= </span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">default </span><span class="s0">is not </span><span class="s1">NoDefault</span>
    <span class="s1">type_param</span><span class="s2">.</span><span class="s1">__default__ </span><span class="s2">= </span><span class="s1">default</span>


<span class="s0">def </span><span class="s1">_set_module</span><span class="s2">(</span><span class="s1">typevarlike</span><span class="s2">):</span>
    <span class="s3"># for pickling:</span>
    <span class="s1">def_mod </span><span class="s2">= </span><span class="s1">_caller</span><span class="s2">(</span><span class="s1">depth</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">def_mod </span><span class="s2">!= </span><span class="s4">'typing_extensions'</span><span class="s2">:</span>
        <span class="s1">typevarlike</span><span class="s2">.</span><span class="s1">__module__ </span><span class="s2">= </span><span class="s1">def_mod</span>


<span class="s0">class </span><span class="s1">_DefaultMixin</span><span class="s2">:</span>
    <span class="s6">&quot;&quot;&quot;Mixin for TypeVarLike defaults.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s2">= ()</span>
    <span class="s1">__init__ </span><span class="s2">= </span><span class="s1">_set_default</span>


<span class="s3"># Classes using this metaclass must provide a _backported_typevarlike ClassVar</span>
<span class="s0">class </span><span class="s1">_TypeVarLikeMeta</span><span class="s2">(</span><span class="s1">type</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__instancecheck__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">__instance</span><span class="s2">: </span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">__instance</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_backported_typevarlike</span><span class="s2">)</span>


<span class="s0">if </span><span class="s1">_PEP_696_IMPLEMENTED</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TypeVar</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s3"># Add default and infer_variance parameters from PEP 696 and 695</span>
    <span class="s0">class </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">_TypeVarLikeMeta</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Type variable.&quot;&quot;&quot;</span>

        <span class="s1">_backported_typevarlike </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span>

        <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, *</span><span class="s1">constraints</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                    <span class="s1">covariant</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">contravariant</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                    <span class="s1">default</span><span class="s2">=</span><span class="s1">NoDefault</span><span class="s2">, </span><span class="s1">infer_variance</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;TypeAliasType&quot;</span><span class="s2">):</span>
                <span class="s3"># PEP 695 implemented (3.12+), can pass infer_variance to typing.TypeVar</span>
                <span class="s1">typevar </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, *</span><span class="s1">constraints</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">bound</span><span class="s2">,</span>
                                         <span class="s1">covariant</span><span class="s2">=</span><span class="s1">covariant</span><span class="s2">, </span><span class="s1">contravariant</span><span class="s2">=</span><span class="s1">contravariant</span><span class="s2">,</span>
                                         <span class="s1">infer_variance</span><span class="s2">=</span><span class="s1">infer_variance</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">typevar </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, *</span><span class="s1">constraints</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">bound</span><span class="s2">,</span>
                                         <span class="s1">covariant</span><span class="s2">=</span><span class="s1">covariant</span><span class="s2">, </span><span class="s1">contravariant</span><span class="s2">=</span><span class="s1">contravariant</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">infer_variance </span><span class="s0">and </span><span class="s2">(</span><span class="s1">covariant </span><span class="s0">or </span><span class="s1">contravariant</span><span class="s2">):</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Variance cannot be specified with infer_variance.&quot;</span><span class="s2">)</span>
                <span class="s1">typevar</span><span class="s2">.</span><span class="s1">__infer_variance__ </span><span class="s2">= </span><span class="s1">infer_variance</span>

            <span class="s1">_set_default</span><span class="s2">(</span><span class="s1">typevar</span><span class="s2">, </span><span class="s1">default</span><span class="s2">)</span>
            <span class="s1">_set_module</span><span class="s2">(</span><span class="s1">typevar</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">_tvar_prepare_subst</span><span class="s2">(</span><span class="s1">alias</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s1">typevar</span><span class="s2">.</span><span class="s1">has_default</span><span class="s2">()</span>
                    <span class="s0">and </span><span class="s1">alias</span><span class="s2">.</span><span class="s1">__parameters__</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">typevar</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
                <span class="s2">):</span>
                    <span class="s1">args </span><span class="s2">+= (</span><span class="s1">typevar</span><span class="s2">.</span><span class="s1">__default__</span><span class="s2">,)</span>
                <span class="s0">return </span><span class="s1">args</span>

            <span class="s1">typevar</span><span class="s2">.</span><span class="s1">__typing_prepare_subst__ </span><span class="s2">= </span><span class="s1">_tvar_prepare_subst</span>
            <span class="s0">return </span><span class="s1">typevar</span>

        <span class="s0">def </span><span class="s1">__init_subclass__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;type '</span><span class="s0">{</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">.TypeVar' is not an acceptable base type&quot;</span><span class="s2">)</span>


<span class="s3"># Python 3.10+ has PEP 612</span>
<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'ParamSpecArgs'</span><span class="s2">):</span>
    <span class="s1">ParamSpecArgs </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ParamSpecArgs</span>
    <span class="s1">ParamSpecKwargs </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ParamSpecKwargs</span>
<span class="s3"># 3.8-3.9</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">_Immutable</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Mixin to indicate that object should not be copied.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ </span><span class="s2">= ()</span>

        <span class="s0">def </span><span class="s1">__copy__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">def </span><span class="s1">__deepcopy__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">class </span><span class="s1">ParamSpecArgs</span><span class="s2">(</span><span class="s1">_Immutable</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;The args for a ParamSpec object. 
 
        Given a ParamSpec object P, P.args is an instance of ParamSpecArgs. 
 
        ParamSpecArgs objects have a reference back to their ParamSpec: 
 
        P.args.__origin__ is P 
 
        This type is meant for runtime introspection and has no special meaning to 
        static type checkers. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s2">= </span><span class="s1">origin</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">.args&quot;</span>

        <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">ParamSpecArgs</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__origin__</span>

    <span class="s0">class </span><span class="s1">ParamSpecKwargs</span><span class="s2">(</span><span class="s1">_Immutable</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;The kwargs for a ParamSpec object. 
 
        Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs. 
 
        ParamSpecKwargs objects have a reference back to their ParamSpec: 
 
        P.kwargs.__origin__ is P 
 
        This type is meant for runtime introspection and has no special meaning to 
        static type checkers. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s2">= </span><span class="s1">origin</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">.kwargs&quot;</span>

        <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">ParamSpecKwargs</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__origin__</span>


<span class="s0">if </span><span class="s1">_PEP_696_IMPLEMENTED</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">ParamSpec</span>

<span class="s3"># 3.10+</span>
<span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'ParamSpec'</span><span class="s2">):</span>

    <span class="s3"># Add default parameter - PEP 696</span>
    <span class="s0">class </span><span class="s1">ParamSpec</span><span class="s2">(</span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">_TypeVarLikeMeta</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Parameter specification.&quot;&quot;&quot;</span>

        <span class="s1">_backported_typevarlike </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ParamSpec</span>

        <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, *, </span><span class="s1">bound</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                    <span class="s1">covariant</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">contravariant</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                    <span class="s1">infer_variance</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s1">NoDefault</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;TypeAliasType&quot;</span><span class="s2">):</span>
                <span class="s3"># PEP 695 implemented, can pass infer_variance to typing.TypeVar</span>
                <span class="s1">paramspec </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ParamSpec</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">bound</span><span class="s2">,</span>
                                             <span class="s1">covariant</span><span class="s2">=</span><span class="s1">covariant</span><span class="s2">,</span>
                                             <span class="s1">contravariant</span><span class="s2">=</span><span class="s1">contravariant</span><span class="s2">,</span>
                                             <span class="s1">infer_variance</span><span class="s2">=</span><span class="s1">infer_variance</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">paramspec </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ParamSpec</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">bound</span><span class="s2">,</span>
                                             <span class="s1">covariant</span><span class="s2">=</span><span class="s1">covariant</span><span class="s2">,</span>
                                             <span class="s1">contravariant</span><span class="s2">=</span><span class="s1">contravariant</span><span class="s2">)</span>
                <span class="s1">paramspec</span><span class="s2">.</span><span class="s1">__infer_variance__ </span><span class="s2">= </span><span class="s1">infer_variance</span>

            <span class="s1">_set_default</span><span class="s2">(</span><span class="s1">paramspec</span><span class="s2">, </span><span class="s1">default</span><span class="s2">)</span>
            <span class="s1">_set_module</span><span class="s2">(</span><span class="s1">paramspec</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">_paramspec_prepare_subst</span><span class="s2">(</span><span class="s1">alias</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
                <span class="s1">params </span><span class="s2">= </span><span class="s1">alias</span><span class="s2">.</span><span class="s1">__parameters__</span>
                <span class="s1">i </span><span class="s2">= </span><span class="s1">params</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">paramspec</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">i </span><span class="s2">== </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) </span><span class="s0">and </span><span class="s1">paramspec</span><span class="s2">.</span><span class="s1">has_default</span><span class="s2">():</span>
                    <span class="s1">args </span><span class="s2">= [*</span><span class="s1">args</span><span class="s2">, </span><span class="s1">paramspec</span><span class="s2">.</span><span class="s1">__default__</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">i </span><span class="s2">&gt;= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">):</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Too few arguments for </span><span class="s0">{</span><span class="s1">alias</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
                <span class="s3"># Special case where Z[[int, str, bool]] == Z[int, str, bool] in PEP 612.</span>
                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">) == </span><span class="s5">1 </span><span class="s0">and not </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_is_param_expr</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]):</span>
                    <span class="s0">assert </span><span class="s1">i </span><span class="s2">== </span><span class="s5">0</span>
                    <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>
                <span class="s3"># Convert lists to tuples to help other libraries cache the results.</span>
                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">list</span><span class="s2">):</span>
                    <span class="s1">args </span><span class="s2">= (*</span><span class="s1">args</span><span class="s2">[:</span><span class="s1">i</span><span class="s2">], </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]), *</span><span class="s1">args</span><span class="s2">[</span><span class="s1">i </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">:])</span>
                <span class="s0">return </span><span class="s1">args</span>

            <span class="s1">paramspec</span><span class="s2">.</span><span class="s1">__typing_prepare_subst__ </span><span class="s2">= </span><span class="s1">_paramspec_prepare_subst</span>
            <span class="s0">return </span><span class="s1">paramspec</span>

        <span class="s0">def </span><span class="s1">__init_subclass__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;type '</span><span class="s0">{</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">.ParamSpec' is not an acceptable base type&quot;</span><span class="s2">)</span>

<span class="s3"># 3.8-3.9</span>
<span class="s0">else</span><span class="s2">:</span>

    <span class="s3"># Inherits from list as a workaround for Callable checks in Python &lt; 3.9.2.</span>
    <span class="s0">class </span><span class="s1">ParamSpec</span><span class="s2">(</span><span class="s1">list</span><span class="s2">, </span><span class="s1">_DefaultMixin</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Parameter specification variable. 
 
        Usage:: 
 
           P = ParamSpec('P') 
 
        Parameter specification variables exist primarily for the benefit of static 
        type checkers.  They are used to forward the parameter types of one 
        callable to another callable, a pattern commonly found in higher order 
        functions and decorators.  They are only valid when used in ``Concatenate``, 
        or s the first argument to ``Callable``. In Python 3.10 and higher, 
        they are also supported in user-defined Generics at runtime. 
        See class Generic for more information on generic types.  An 
        example for annotating a decorator:: 
 
           T = TypeVar('T') 
           P = ParamSpec('P') 
 
           def add_logging(f: Callable[P, T]) -&gt; Callable[P, T]: 
               '''A type-safe decorator to add logging to a function.''' 
               def inner(*args: P.args, **kwargs: P.kwargs) -&gt; T: 
                   logging.info(f'{f.__name__} was called') 
                   return f(*args, **kwargs) 
               return inner 
 
           @add_logging 
           def add_two(x: float, y: float) -&gt; float: 
               '''Add two numbers together.''' 
               return x + y 
 
        Parameter specification variables defined with covariant=True or 
        contravariant=True can be used to declare covariant or contravariant 
        generic types.  These keyword arguments are valid, but their actual semantics 
        are yet to be decided.  See PEP 612 for details. 
 
        Parameter specification variables can be introspected. e.g.: 
 
           P.__name__ == 'T' 
           P.__bound__ == None 
           P.__covariant__ == False 
           P.__contravariant__ == False 
 
        Note that only parameter specification variables defined in global scope can 
        be pickled. 
        &quot;&quot;&quot;</span>

        <span class="s3"># Trick Generic __parameters__.</span>
        <span class="s1">__class__ </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span>

        <span class="s2">@</span><span class="s1">property</span>
        <span class="s0">def </span><span class="s1">args</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">ParamSpecArgs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s2">@</span><span class="s1">property</span>
        <span class="s0">def </span><span class="s1">kwargs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">ParamSpecKwargs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, *, </span><span class="s1">bound</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">covariant</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">contravariant</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                     <span class="s1">infer_variance</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s1">NoDefault</span><span class="s2">):</span>
            <span class="s1">list</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, [</span><span class="s1">self</span><span class="s2">])</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s1">name</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__covariant__ </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">covariant</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__contravariant__ </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">contravariant</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__infer_variance__ </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">infer_variance</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">bound</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__bound__ </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">bound</span><span class="s2">, </span><span class="s4">'Bound must be a type.'</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__bound__ </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s1">_DefaultMixin</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">default</span><span class="s2">)</span>

            <span class="s3"># for pickling:</span>
            <span class="s1">def_mod </span><span class="s2">= </span><span class="s1">_caller</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">def_mod </span><span class="s2">!= </span><span class="s4">'typing_extensions'</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__module__ </span><span class="s2">= </span><span class="s1">def_mod</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__infer_variance__</span><span class="s2">:</span>
                <span class="s1">prefix </span><span class="s2">= </span><span class="s4">''</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__covariant__</span><span class="s2">:</span>
                <span class="s1">prefix </span><span class="s2">= </span><span class="s4">'+'</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__contravariant__</span><span class="s2">:</span>
                <span class="s1">prefix </span><span class="s2">= </span><span class="s4">'-'</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">prefix </span><span class="s2">= </span><span class="s4">'~'</span>
            <span class="s0">return </span><span class="s1">prefix </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__name__</span>

        <span class="s0">def </span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

        <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__name__</span>

        <span class="s3"># Hack to get typing._type_check to pass.</span>
        <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s0">pass</span>


<span class="s3"># 3.8-3.9</span>
<span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'Concatenate'</span><span class="s2">):</span>
    <span class="s3"># Inherits from list as a workaround for Callable checks in Python &lt; 3.9.2.</span>

    <span class="s3"># 3.9.0-1</span>
    <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'_type_convert'</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">_type_convert</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">module</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">allow_special_forms</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
            <span class="s6">&quot;&quot;&quot;For converting None to type(None), and strings to ForwardRef.&quot;&quot;&quot;</span>
            <span class="s0">if </span><span class="s1">arg </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">6</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">ForwardRef</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">7</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">ForwardRef</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">module</span><span class="s2">=</span><span class="s1">module</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">ForwardRef</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">module</span><span class="s2">=</span><span class="s1">module</span><span class="s2">, </span><span class="s1">is_class</span><span class="s2">=</span><span class="s1">allow_special_forms</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">arg</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">_type_convert </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_convert</span>

    <span class="s0">class </span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">(</span><span class="s1">list</span><span class="s2">):</span>

        <span class="s3"># Trick Generic into looking into this for __parameters__.</span>
        <span class="s1">__class__ </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span>

        <span class="s3"># Flag in 3.8.</span>
        <span class="s1">_special </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s2">= </span><span class="s1">origin</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__args__ </span><span class="s2">= </span><span class="s1">args</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s1">_type_repr </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_repr</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s4">f'</span><span class="s0">{</span><span class="s1">_type_repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">)</span><span class="s0">}</span><span class="s4">'</span>
                    <span class="s4">f'[</span><span class="s0">{</span><span class="s4">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">_type_repr</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">)</span><span class="s0">}</span><span class="s4">]'</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">hash</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">))</span>

        <span class="s3"># Hack to get typing._type_check to pass in Generic.</span>
        <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s0">pass</span>

        <span class="s2">@</span><span class="s1">property</span>
        <span class="s0">def </span><span class="s1">__parameters__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span>
                <span class="s1">tp </span><span class="s0">for </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__ </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, (</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">, </span><span class="s1">ParamSpec</span><span class="s2">))</span>
            <span class="s2">)</span>

        <span class="s3"># 3.8; needed for typing._subst_tvars</span>
        <span class="s3"># 3.9 used by __getitem__ below</span>
        <span class="s0">def </span><span class="s1">copy_with</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">):</span>
                <span class="s1">params </span><span class="s2">= (*</span><span class="s1">params</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">], *</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">].</span><span class="s1">__args__</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)):</span>
                <span class="s0">return </span><span class="s2">(*</span><span class="s1">params</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">], *</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">])</span>
            <span class="s0">elif </span><span class="s2">(</span><span class="s0">not </span><span class="s2">(</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] </span><span class="s0">is </span><span class="s2">... </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">ParamSpec</span><span class="s2">))):</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;The last parameter to Concatenate should be a &quot;</span>
                        <span class="s4">&quot;ParamSpec variable or ellipsis.&quot;</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">, </span><span class="s1">params</span><span class="s2">)</span>

        <span class="s3"># 3.9; accessed during GenericAlias.__getitem__ when substituting</span>
        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s0">in </span><span class="s2">(</span><span class="s1">Generic</span><span class="s2">, </span><span class="s1">Protocol</span><span class="s2">):</span>
                <span class="s3"># Can't subscript Generic[...] or Protocol[...].</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Cannot subscript already-subscripted </span><span class="s0">{</span><span class="s1">self</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__parameters__</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">is not a generic class&quot;</span><span class="s2">)</span>

            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>
            <span class="s1">args </span><span class="s2">= </span><span class="s1">_unpack_args</span><span class="s2">(*(</span><span class="s1">_type_convert</span><span class="s2">(</span><span class="s1">p</span><span class="s2">) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">args</span><span class="s2">))</span>
            <span class="s1">params </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__parameters__</span>
            <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">params</span><span class="s2">:</span>
                <span class="s1">prepare </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">param</span><span class="s2">, </span><span class="s4">&quot;__typing_prepare_subst__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">prepare </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">args </span><span class="s2">= </span><span class="s1">prepare</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
                <span class="s3"># 3.8 - 3.9 &amp; typing.ParamSpec</span>
                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">param</span><span class="s2">, </span><span class="s1">ParamSpec</span><span class="s2">):</span>
                    <span class="s1">i </span><span class="s2">= </span><span class="s1">params</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">param</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s2">(</span>
                        <span class="s1">i </span><span class="s2">== </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
                        <span class="s0">and </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">param</span><span class="s2">, </span><span class="s4">'__default__'</span><span class="s2">, </span><span class="s1">NoDefault</span><span class="s2">) </span><span class="s0">is not </span><span class="s1">NoDefault</span>
                    <span class="s2">):</span>
                        <span class="s1">args </span><span class="s2">= [*</span><span class="s1">args</span><span class="s2">, </span><span class="s1">param</span><span class="s2">.</span><span class="s1">__default__</span><span class="s2">]</span>
                    <span class="s0">if </span><span class="s1">i </span><span class="s2">&gt;= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">):</span>
                        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Too few arguments for </span><span class="s0">{</span><span class="s1">self</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
                    <span class="s3"># Special case for Z[[int, str, bool]] == Z[int, str, bool]</span>
                    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">) == </span><span class="s5">1 </span><span class="s0">and not </span><span class="s1">_is_param_expr</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]):</span>
                        <span class="s0">assert </span><span class="s1">i </span><span class="s2">== </span><span class="s5">0</span>
                        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>
                    <span class="s0">elif </span><span class="s2">(</span>
                        <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">list</span><span class="s2">)</span>
                        <span class="s3"># 3.8 - 3.9</span>
                        <span class="s3"># This class inherits from list do not convert</span>
                        <span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">)</span>
                    <span class="s2">):</span>
                        <span class="s1">args </span><span class="s2">= (*</span><span class="s1">args</span><span class="s2">[:</span><span class="s1">i</span><span class="s2">], </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]), *</span><span class="s1">args</span><span class="s2">[</span><span class="s1">i </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">:])</span>

            <span class="s1">alen </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">plen </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">alen </span><span class="s2">!= </span><span class="s1">plen</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                    <span class="s4">f&quot;Too </span><span class="s0">{</span><span class="s4">'many' </span><span class="s0">if </span><span class="s1">alen </span><span class="s2">&gt; </span><span class="s1">plen </span><span class="s0">else </span><span class="s4">'few'</span><span class="s0">} </span><span class="s4">arguments for </span><span class="s0">{</span><span class="s1">self</span><span class="s0">}</span><span class="s4">;&quot;</span>
                    <span class="s4">f&quot; actual </span><span class="s0">{</span><span class="s1">alen</span><span class="s0">}</span><span class="s4">, expected </span><span class="s0">{</span><span class="s1">plen</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s2">)</span>

            <span class="s1">subst </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__parameters__</span><span class="s2">, </span><span class="s1">args</span><span class="s2">))</span>
            <span class="s3"># determine new args</span>
            <span class="s1">new_args </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
                    <span class="s1">new_args</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
                    <span class="s0">continue</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">TypeVar</span><span class="s2">):</span>
                    <span class="s1">arg </span><span class="s2">= </span><span class="s1">subst</span><span class="s2">[</span><span class="s1">arg</span><span class="s2">]</span>
                    <span class="s0">if </span><span class="s2">(</span>
                        <span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">) </span><span class="s0">and </span><span class="s1">_is_unpack</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">))</span>
                        <span class="s0">or </span><span class="s2">(</span>
                            <span class="s1">hasattr</span><span class="s2">(</span><span class="s1">_types</span><span class="s2">, </span><span class="s4">&quot;GenericAlias&quot;</span><span class="s2">)</span>
                            <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">)</span>
                            <span class="s0">and </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s4">&quot;__unpacked__&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
                        <span class="s2">)</span>
                    <span class="s2">):</span>
                        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">arg</span><span class="s0">} </span><span class="s4">is not valid as type argument&quot;</span><span class="s2">)</span>

                <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">,</span>
                    <span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span>
                    <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">_types</span><span class="s2">, </span><span class="s4">&quot;GenericAlias&quot;</span><span class="s2">) </span><span class="s0">else</span>
                    <span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">)</span>
                <span class="s2">):</span>
                    <span class="s1">subparams </span><span class="s2">= </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">__parameters__</span>
                    <span class="s0">if </span><span class="s1">subparams</span><span class="s2">:</span>
                        <span class="s1">subargs </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">subst</span><span class="s2">[</span><span class="s1">x</span><span class="s2">] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">subparams</span><span class="s2">)</span>
                        <span class="s1">arg </span><span class="s2">= </span><span class="s1">arg</span><span class="s2">[</span><span class="s1">subargs</span><span class="s2">]</span>
                <span class="s1">new_args</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy_with</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">new_args</span><span class="s2">))</span>

<span class="s3"># 3.10+</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s1">_ConcatenateGenericAlias </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_ConcatenateGenericAlias</span>

    <span class="s3"># 3.10</span>
    <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">11</span><span class="s2">):</span>

        <span class="s0">class </span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
            <span class="s3"># needed for checks in collections.abc.Callable to accept this class</span>
            <span class="s1">__module__ </span><span class="s2">= </span><span class="s4">&quot;typing&quot;</span>

            <span class="s0">def </span><span class="s1">copy_with</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)):</span>
                    <span class="s0">return </span><span class="s2">(*</span><span class="s1">params</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">], *</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">])</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">):</span>
                    <span class="s1">params </span><span class="s2">= (*</span><span class="s1">params</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">], *</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">].</span><span class="s1">__args__</span><span class="s2">)</span>
                <span class="s0">elif not </span><span class="s2">(</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] </span><span class="s0">is </span><span class="s2">... </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">params</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">ParamSpec</span><span class="s2">)):</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;The last parameter to Concatenate should be a &quot;</span>
                            <span class="s4">&quot;ParamSpec variable or ellipsis.&quot;</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">super</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">, </span><span class="s1">self</span><span class="s2">).</span><span class="s1">copy_with</span><span class="s2">(</span><span class="s1">params</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">any</span><span class="s2">(</span><span class="s1">_is_unpack</span><span class="s2">(</span><span class="s1">t</span><span class="s2">) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">value</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">_unpack_args</span><span class="s2">(*(</span><span class="s1">n </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">value</span><span class="s2">)))</span>
                <span class="s0">return </span><span class="s1">value</span>


<span class="s3"># 3.8-3.9.2</span>
<span class="s0">class </span><span class="s1">_EllipsisDummy</span><span class="s2">: ...</span>


<span class="s3"># 3.8-3.10</span>
<span class="s0">def </span><span class="s1">_create_concatenate_alias</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">parameters</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] </span><span class="s0">is </span><span class="s2">... </span><span class="s0">and </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">2</span><span class="s2">):</span>
        <span class="s3"># Hack: Arguments must be types, replace it with one.</span>
        <span class="s1">parameters </span><span class="s2">= (*</span><span class="s1">parameters</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">_EllipsisDummy</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">3</span><span class="s2">):</span>
        <span class="s1">concatenate </span><span class="s2">= </span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">,</span>
                                        <span class="s1">_typevar_types</span><span class="s2">=(</span><span class="s1">TypeVar</span><span class="s2">, </span><span class="s1">ParamSpec</span><span class="s2">),</span>
                                        <span class="s1">_paramspec_tvars</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">concatenate </span><span class="s2">= </span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">parameters</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] </span><span class="s0">is not </span><span class="s1">_EllipsisDummy</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">concatenate</span>
    <span class="s3"># Remove dummy again</span>
    <span class="s1">concatenate</span><span class="s2">.</span><span class="s1">__args__ </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">p </span><span class="s0">if </span><span class="s1">p </span><span class="s0">is not </span><span class="s1">_EllipsisDummy </span><span class="s0">else </span><span class="s2">...</span>
                                    <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">concatenate</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">):</span>
        <span class="s3"># backport needs __args__ adjustment only</span>
        <span class="s0">return </span><span class="s1">concatenate</span>
    <span class="s1">concatenate</span><span class="s2">.</span><span class="s1">__parameters__ </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">p </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">concatenate</span><span class="s2">.</span><span class="s1">__parameters__</span>
                                        <span class="s0">if </span><span class="s1">p </span><span class="s0">is not </span><span class="s1">_EllipsisDummy</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">concatenate</span>


<span class="s3"># 3.8-3.10</span>
<span class="s2">@</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_tp_cache</span>
<span class="s0">def </span><span class="s1">_concatenate_getitem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">parameters </span><span class="s2">== ():</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Cannot take a Concatenate of no types.&quot;</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s1">parameters </span><span class="s2">= (</span><span class="s1">parameters</span><span class="s2">,)</span>
    <span class="s0">if not </span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] </span><span class="s0">is </span><span class="s2">... </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">ParamSpec</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;The last parameter to Concatenate should be a &quot;</span>
                        <span class="s4">&quot;ParamSpec variable or ellipsis.&quot;</span><span class="s2">)</span>
    <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;Concatenate[arg, ...]: each arg must be a type.&quot;</span>
    <span class="s1">parameters </span><span class="s2">= (*(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">]),</span>
                    <span class="s1">parameters</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">])</span>
    <span class="s0">return </span><span class="s1">_create_concatenate_alias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">)</span>


<span class="s3"># 3.11+; Concatenate does not accept ellipsis in 3.10</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">11</span><span class="s2">):</span>
    <span class="s1">Concatenate </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Concatenate</span>
<span class="s3"># 3.9-3.10</span>
<span class="s0">elif </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">] &gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">Concatenate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a 
        higher order function which adds, removes or transforms parameters of a 
        callable. 
 
        For example:: 
 
           Callable[Concatenate[int, P], int] 
 
        See PEP 612 for detailed information. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_concatenate_getitem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">)</span>
<span class="s3"># 3.8</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">_ConcatenateForm</span><span class="s2">(</span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">_concatenate_getitem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">)</span>

    <span class="s1">Concatenate </span><span class="s2">= </span><span class="s1">_ConcatenateForm</span><span class="s2">(</span>
        <span class="s4">'Concatenate'</span><span class="s2">,</span>
        <span class="s1">doc</span><span class="s2">=</span><span class="s4">&quot;&quot;&quot;Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a 
        higher order function which adds, removes or transforms parameters of a 
        callable. 
 
        For example:: 
 
           Callable[Concatenate[int, P], int] 
 
        See PEP 612 for detailed information. 
        &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s3"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'TypeGuard'</span><span class="s2">):</span>
    <span class="s1">TypeGuard </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeGuard</span>
<span class="s3"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">] &gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">TypeGuard</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type guard function.  ``TypeGuard`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeGuard`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the type inside ``TypeGuard``. 
 
        For example:: 
 
            def is_str(val: Union[str, float]): 
                # &quot;isinstance&quot; type guard 
                if isinstance(val, str): 
                    # Type of ``val`` is narrowed to ``str`` 
                    ... 
                else: 
                    # Else, type of ``val`` is narrowed to ``float``. 
                    ... 
 
        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower 
        form of ``TypeA`` (it can even be a wider form) and this may lead to 
        type-unsafe results.  The main reason is to allow for things like 
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not 
        a subtype of the former, since ``List`` is invariant.  The responsibility of 
        writing type-safe type guards is left to the user. 
 
        ``TypeGuard`` also works with type variables.  For more information, see 
        PEP 647 (User-Defined Type Guards). 
        &quot;&quot;&quot;</span>
        <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">, </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>
<span class="s3"># 3.8</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">_TypeGuardForm</span><span class="s2">(</span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
            <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">,</span>
                                      <span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">} </span><span class="s4">accepts only a single type'</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>

    <span class="s1">TypeGuard </span><span class="s2">= </span><span class="s1">_TypeGuardForm</span><span class="s2">(</span>
        <span class="s4">'TypeGuard'</span><span class="s2">,</span>
        <span class="s1">doc</span><span class="s2">=</span><span class="s4">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type guard function.  ``TypeGuard`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeGuard`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the type inside ``TypeGuard``. 
 
        For example:: 
 
            def is_str(val: Union[str, float]): 
                # &quot;isinstance&quot; type guard 
                if isinstance(val, str): 
                    # Type of ``val`` is narrowed to ``str`` 
                    ... 
                else: 
                    # Else, type of ``val`` is narrowed to ``float``. 
                    ... 
 
        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower 
        form of ``TypeA`` (it can even be a wider form) and this may lead to 
        type-unsafe results.  The main reason is to allow for things like 
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not 
        a subtype of the former, since ``List`` is invariant.  The responsibility of 
        writing type-safe type guards is left to the user. 
 
        ``TypeGuard`` also works with type variables.  For more information, see 
        PEP 647 (User-Defined Type Guards). 
        &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s3"># 3.13+</span>
<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'TypeIs'</span><span class="s2">):</span>
    <span class="s1">TypeIs </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeIs</span>
<span class="s3"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">] &gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">TypeIs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type narrower function.  ``TypeIs`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeIs`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeIs[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeIs`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the intersection of the type inside ``TypeIs`` and the argument's 
        previously known type. 
 
        For example:: 
 
            def is_awaitable(val: object) -&gt; TypeIs[Awaitable[Any]]: 
                return hasattr(val, '__await__') 
 
            def f(val: Union[int, Awaitable[int]]) -&gt; int: 
                if is_awaitable(val): 
                    assert_type(val, Awaitable[int]) 
                else: 
                    assert_type(val, int) 
 
        ``TypeIs`` also works with type variables.  For more information, see 
        PEP 742 (Narrowing types with TypeIs). 
        &quot;&quot;&quot;</span>
        <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">, </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>
<span class="s3"># 3.8</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">_TypeIsForm</span><span class="s2">(</span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
            <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">,</span>
                                      <span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">} </span><span class="s4">accepts only a single type'</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>

    <span class="s1">TypeIs </span><span class="s2">= </span><span class="s1">_TypeIsForm</span><span class="s2">(</span>
        <span class="s4">'TypeIs'</span><span class="s2">,</span>
        <span class="s1">doc</span><span class="s2">=</span><span class="s4">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type narrower function.  ``TypeIs`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeIs`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeIs[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeIs`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the intersection of the type inside ``TypeIs`` and the argument's 
        previously known type. 
 
        For example:: 
 
            def is_awaitable(val: object) -&gt; TypeIs[Awaitable[Any]]: 
                return hasattr(val, '__await__') 
 
            def f(val: Union[int, Awaitable[int]]) -&gt; int: 
                if is_awaitable(val): 
                    assert_type(val, Awaitable[int]) 
                else: 
                    assert_type(val, int) 
 
        ``TypeIs`` also works with type variables.  For more information, see 
        PEP 742 (Narrowing types with TypeIs). 
        &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s3"># 3.14+?</span>
<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'TypeForm'</span><span class="s2">):</span>
    <span class="s1">TypeForm </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeForm</span>
<span class="s3"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">] &gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
    <span class="s0">class </span><span class="s1">_TypeFormForm</span><span class="s2">(</span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s3"># TypeForm(X) is equivalent to X but indicates to the type checker</span>
        <span class="s3"># that the object is a TypeForm.</span>
        <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, /):</span>
            <span class="s0">return </span><span class="s1">obj</span>

    <span class="s2">@</span><span class="s1">_TypeFormForm</span>
    <span class="s0">def </span><span class="s1">TypeForm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;A special form representing the value that results from the evaluation 
        of a type expression. This value encodes the information supplied in the 
        type expression, and it represents the type described by that type expression. 
 
        When used in a type expression, TypeForm describes a set of type form objects. 
        It accepts a single type argument, which must be a valid type expression. 
        ``TypeForm[T]`` describes the set of all type form objects that represent 
        the type T or types that are assignable to T. 
 
        Usage: 
 
            def cast[T](typ: TypeForm[T], value: Any) -&gt; T: ... 
 
            reveal_type(cast(int, &quot;x&quot;))  # int 
 
        See PEP 747 for more information. 
        &quot;&quot;&quot;</span>
        <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">, </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>
<span class="s3"># 3.8</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">_TypeFormForm</span><span class="s2">(</span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
            <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">,</span>
                                      <span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">} </span><span class="s4">accepts only a single type'</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>

        <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, /):</span>
            <span class="s0">return </span><span class="s1">obj</span>

    <span class="s1">TypeForm </span><span class="s2">= </span><span class="s1">_TypeFormForm</span><span class="s2">(</span>
        <span class="s4">'TypeForm'</span><span class="s2">,</span>
        <span class="s1">doc</span><span class="s2">=</span><span class="s4">&quot;&quot;&quot;A special form representing the value that results from the evaluation 
        of a type expression. This value encodes the information supplied in the 
        type expression, and it represents the type described by that type expression. 
 
        When used in a type expression, TypeForm describes a set of type form objects. 
        It accepts a single type argument, which must be a valid type expression. 
        ``TypeForm[T]`` describes the set of all type form objects that represent 
        the type T or types that are assignable to T. 
 
        Usage: 
 
            def cast[T](typ: TypeForm[T], value: Any) -&gt; T: ... 
 
            reveal_type(cast(int, &quot;x&quot;))  # int 
 
        See PEP 747 for more information. 
        &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s3"># Vendored from cpython typing._SpecialFrom</span>
<span class="s0">class </span><span class="s1">_SpecialForm</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_Final</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s1">__slots__ </span><span class="s2">= (</span><span class="s4">'_name'</span><span class="s2">, </span><span class="s4">'__doc__'</span><span class="s2">, </span><span class="s4">'_getitem'</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">getitem</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_getitem </span><span class="s2">= </span><span class="s1">getitem</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_name </span><span class="s2">= </span><span class="s1">getitem</span><span class="s2">.</span><span class="s1">__name__</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">getitem</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s0">def </span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">item </span><span class="s0">in </span><span class="s2">{</span><span class="s4">'__name__'</span><span class="s2">, </span><span class="s4">'__qualname__'</span><span class="s2">}:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span>

        <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">item</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__mro_entries__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Cannot subclass </span><span class="s0">{</span><span class="s1">self</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">f'typing_extensions.</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">}</span><span class="s4">'</span>

    <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Cannot instantiate </span><span class="s0">{</span><span class="s1">self</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__or__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">__ror__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">other</span><span class="s2">, </span><span class="s1">self</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">__instancecheck__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">cannot be used with isinstance()&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__subclasscheck__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">cannot be used with issubclass()&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_tp_cache</span>
    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getitem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">)</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;LiteralString&quot;</span><span class="s2">):  </span><span class="s3"># 3.11+</span>
    <span class="s1">LiteralString </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">LiteralString</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s2">@</span><span class="s1">_SpecialForm</span>
    <span class="s0">def </span><span class="s1">LiteralString</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Represents an arbitrary literal string. 
 
        Example:: 
 
          from pip._vendor.typing_extensions import LiteralString 
 
          def query(sql: LiteralString) -&gt; ...: 
              ... 
 
          query(&quot;SELECT * FROM table&quot;)  # ok 
          query(f&quot;SELECT * FROM {input()}&quot;)  # not ok 
 
        See PEP 675 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">is not subscriptable&quot;</span><span class="s2">)</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;Self&quot;</span><span class="s2">):  </span><span class="s3"># 3.11+</span>
    <span class="s1">Self </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Self</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s2">@</span><span class="s1">_SpecialForm</span>
    <span class="s0">def </span><span class="s1">Self</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Used to spell the type of &quot;self&quot; in classes. 
 
        Example:: 
 
          from typing import Self 
 
          class ReturnsSelf: 
              def parse(self, data: bytes) -&gt; Self: 
                  ... 
                  return self 
 
        &quot;&quot;&quot;</span>

        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">is not subscriptable&quot;</span><span class="s2">)</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;Never&quot;</span><span class="s2">):  </span><span class="s3"># 3.11+</span>
    <span class="s1">Never </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Never</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s2">@</span><span class="s1">_SpecialForm</span>
    <span class="s0">def </span><span class="s1">Never</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;The bottom type, a type that has no members. 
 
        This can be used to define a function that should never be 
        called, or a function that never returns:: 
 
            from pip._vendor.typing_extensions import Never 
 
            def never_call_me(arg: Never) -&gt; None: 
                pass 
 
            def int_or_str(arg: int | str) -&gt; None: 
                never_call_me(arg)  # type checker error 
                match arg: 
                    case int(): 
                        print(&quot;It's an int&quot;) 
                    case str(): 
                        print(&quot;It's a str&quot;) 
                    case _: 
                        never_call_me(arg)  # ok, arg is of type Never 
 
        &quot;&quot;&quot;</span>

        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">is not subscriptable&quot;</span><span class="s2">)</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'Required'</span><span class="s2">):  </span><span class="s3"># 3.11+</span>
    <span class="s1">Required </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Required</span>
    <span class="s1">NotRequired </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">NotRequired</span>
<span class="s0">elif </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">] &gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):  </span><span class="s3"># 3.9-3.10</span>
    <span class="s2">@</span><span class="s1">_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">Required</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;A special typing construct to mark a key of a total=False TypedDict 
        as required. For example: 
 
            class Movie(TypedDict, total=False): 
                title: Required[str] 
                year: int 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
 
        There is no runtime checking that a required key is actually provided 
        when instantiating a related TypedDict. 
        &quot;&quot;&quot;</span>
        <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">, </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>

    <span class="s2">@</span><span class="s1">_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">NotRequired</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;A special typing construct to mark a key of a TypedDict as 
        potentially missing. For example: 
 
            class Movie(TypedDict): 
                title: str 
                year: NotRequired[int] 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
        &quot;&quot;&quot;</span>
        <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">, </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>

<span class="s0">else</span><span class="s2">:  </span><span class="s3"># 3.8</span>
    <span class="s0">class </span><span class="s1">_RequiredForm</span><span class="s2">(</span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
            <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">,</span>
                                      <span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>

    <span class="s1">Required </span><span class="s2">= </span><span class="s1">_RequiredForm</span><span class="s2">(</span>
        <span class="s4">'Required'</span><span class="s2">,</span>
        <span class="s1">doc</span><span class="s2">=</span><span class="s4">&quot;&quot;&quot;A special typing construct to mark a key of a total=False TypedDict 
        as required. For example: 
 
            class Movie(TypedDict, total=False): 
                title: Required[str] 
                year: int 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
 
        There is no runtime checking that a required key is actually provided 
        when instantiating a related TypedDict. 
        &quot;&quot;&quot;</span><span class="s2">)</span>
    <span class="s1">NotRequired </span><span class="s2">= </span><span class="s1">_RequiredForm</span><span class="s2">(</span>
        <span class="s4">'NotRequired'</span><span class="s2">,</span>
        <span class="s1">doc</span><span class="s2">=</span><span class="s4">&quot;&quot;&quot;A special typing construct to mark a key of a TypedDict as 
        potentially missing. For example: 
 
            class Movie(TypedDict): 
                title: str 
                year: NotRequired[int] 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
        &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'ReadOnly'</span><span class="s2">):</span>
    <span class="s1">ReadOnly </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ReadOnly</span>
<span class="s0">elif </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">] &gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):  </span><span class="s3"># 3.9-3.12</span>
    <span class="s2">@</span><span class="s1">_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">ReadOnly</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;A special typing construct to mark an item of a TypedDict as read-only. 
 
        For example: 
 
            class Movie(TypedDict): 
                title: ReadOnly[str] 
                year: int 
 
            def mutate_movie(m: Movie) -&gt; None: 
                m[&quot;year&quot;] = 1992  # allowed 
                m[&quot;title&quot;] = &quot;The Matrix&quot;  # typechecker error 
 
        There is no runtime checking for this property. 
        &quot;&quot;&quot;</span>
        <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">, </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>

<span class="s0">else</span><span class="s2">:  </span><span class="s3"># 3.8</span>
    <span class="s0">class </span><span class="s1">_ReadOnlyForm</span><span class="s2">(</span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
            <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">,</span>
                                      <span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>

    <span class="s1">ReadOnly </span><span class="s2">= </span><span class="s1">_ReadOnlyForm</span><span class="s2">(</span>
        <span class="s4">'ReadOnly'</span><span class="s2">,</span>
        <span class="s1">doc</span><span class="s2">=</span><span class="s4">&quot;&quot;&quot;A special typing construct to mark a key of a TypedDict as read-only. 
 
        For example: 
 
            class Movie(TypedDict): 
                title: ReadOnly[str] 
                year: int 
 
            def mutate_movie(m: Movie) -&gt; None: 
                m[&quot;year&quot;] = 1992  # allowed 
                m[&quot;title&quot;] = &quot;The Matrix&quot;  # typechecker error 
 
        There is no runtime checking for this propery. 
        &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s1">_UNPACK_DOC </span><span class="s2">= </span><span class="s4">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s4">Type unpack operator. 
 
The type unpack operator takes the child types from some container type, 
such as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For 
example: 
 
  # For some generic class `Foo`: 
  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str] 
 
  Ts = TypeVarTuple('Ts') 
  # Specifies that `Bar` is generic in an arbitrary number of types. 
  # (Think of `Ts` as a tuple of an arbitrary number of individual 
  #  `TypeVar`s, which the `Unpack` is 'pulling out' directly into the 
  #  `Generic[]`.) 
  class Bar(Generic[Unpack[Ts]]): ... 
  Bar[int]  # Valid 
  Bar[int, str]  # Also valid 
 
From Python 3.11, this can also be done using the `*` operator: 
 
    Foo[*tuple[int, str]] 
    class Bar(Generic[*Ts]): ... 
 
The operator can also be used along with a `TypedDict` to annotate 
`**kwargs` in a function signature. For instance: 
 
  class Movie(TypedDict): 
    name: str 
    year: int 
 
  # This function expects two keyword arguments - *name* of type `str` and 
  # *year* of type `int`. 
  def foo(**kwargs: Unpack[Movie]): ... 
 
Note that there is only some runtime checking of this operator. Not 
everything the runtime allows may be accepted by static type checkers. 
 
For more information, see PEP 646 and PEP 692. 
&quot;&quot;&quot;</span>


<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">):  </span><span class="s3"># PEP 692 changed the repr of Unpack[]</span>
    <span class="s1">Unpack </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Unpack</span>

    <span class="s0">def </span><span class="s1">_is_unpack</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">) </span><span class="s0">is </span><span class="s1">Unpack</span>

<span class="s0">elif </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">] &gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):  </span><span class="s3"># 3.9+</span>
    <span class="s0">class </span><span class="s1">_UnpackSpecialForm</span><span class="s2">(</span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">getitem</span><span class="s2">):</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">getitem</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_UNPACK_DOC</span>

    <span class="s0">class </span><span class="s1">_UnpackAlias</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">11</span><span class="s2">):</span>
            <span class="s3"># needed for compatibility with Generic[Unpack[Ts]]</span>
            <span class="s1">__class__ </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span>

        <span class="s2">@</span><span class="s1">property</span>
        <span class="s0">def </span><span class="s1">__typing_unpacked_tuple_args__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s0">is </span><span class="s1">Unpack</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">) == </span><span class="s5">1</span>
            <span class="s1">arg</span><span class="s2">, = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, (</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">)):</span>
                <span class="s0">if </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s0">is not </span><span class="s1">tuple</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Unpack[...] must be used with a tuple type&quot;</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">__args__</span>
            <span class="s0">return None</span>

        <span class="s2">@</span><span class="s1">property</span>
        <span class="s0">def </span><span class="s1">__typing_is_unpacked_typevartuple__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s0">is </span><span class="s1">Unpack</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">) == </span><span class="s5">1</span>
            <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">TypeVarTuple</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__typing_is_unpacked_typevartuple__</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">args</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">_UnpackSpecialForm</span>
    <span class="s0">def </span><span class="s1">Unpack</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
        <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">, </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">_UnpackAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>

    <span class="s0">def </span><span class="s1">_is_unpack</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">_UnpackAlias</span><span class="s2">)</span>

<span class="s0">else</span><span class="s2">:  </span><span class="s3"># 3.8</span>
    <span class="s0">class </span><span class="s1">_UnpackAlias</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s1">__class__ </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span>

        <span class="s2">@</span><span class="s1">property</span>
        <span class="s0">def </span><span class="s1">__typing_unpacked_tuple_args__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s0">is </span><span class="s1">Unpack</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">) == </span><span class="s5">1</span>
            <span class="s1">arg</span><span class="s2">, = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s0">is not </span><span class="s1">tuple</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Unpack[...] must be used with a tuple type&quot;</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">__args__</span>
            <span class="s0">return None</span>

        <span class="s2">@</span><span class="s1">property</span>
        <span class="s0">def </span><span class="s1">__typing_is_unpacked_typevartuple__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__ </span><span class="s0">is </span><span class="s1">Unpack</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">) == </span><span class="s5">1</span>
            <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__args__</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">TypeVarTuple</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__typing_is_unpacked_typevartuple__</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">args</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s0">class </span><span class="s1">_UnpackForm</span><span class="s2">(</span><span class="s1">_ExtensionsSpecialForm</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
            <span class="s1">item </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">,</span>
                                      <span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">_UnpackAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s1">item</span><span class="s2">,))</span>

    <span class="s1">Unpack </span><span class="s2">= </span><span class="s1">_UnpackForm</span><span class="s2">(</span><span class="s4">'Unpack'</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">=</span><span class="s1">_UNPACK_DOC</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_is_unpack</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">_UnpackAlias</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_unpack_args</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">newargs </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args</span><span class="s2">:</span>
        <span class="s1">subargs </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s4">'__typing_unpacked_tuple_args__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">subargs </span><span class="s0">is not None and </span><span class="s2">(</span><span class="s0">not </span><span class="s2">(</span><span class="s1">subargs </span><span class="s0">and </span><span class="s1">subargs</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] </span><span class="s0">is </span><span class="s2">...)):</span>
            <span class="s1">newargs</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">subargs</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">newargs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">newargs</span>


<span class="s0">if </span><span class="s1">_PEP_696_IMPLEMENTED</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TypeVarTuple</span>

<span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;TypeVarTuple&quot;</span><span class="s2">):  </span><span class="s3"># 3.11+</span>

    <span class="s3"># Add default parameter - PEP 696</span>
    <span class="s0">class </span><span class="s1">TypeVarTuple</span><span class="s2">(</span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">_TypeVarLikeMeta</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Type variable tuple.&quot;&quot;&quot;</span>

        <span class="s1">_backported_typevarlike </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVarTuple</span>

        <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, *, </span><span class="s1">default</span><span class="s2">=</span><span class="s1">NoDefault</span><span class="s2">):</span>
            <span class="s1">tvt </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVarTuple</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s1">_set_default</span><span class="s2">(</span><span class="s1">tvt</span><span class="s2">, </span><span class="s1">default</span><span class="s2">)</span>
            <span class="s1">_set_module</span><span class="s2">(</span><span class="s1">tvt</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">_typevartuple_prepare_subst</span><span class="s2">(</span><span class="s1">alias</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
                <span class="s1">params </span><span class="s2">= </span><span class="s1">alias</span><span class="s2">.</span><span class="s1">__parameters__</span>
                <span class="s1">typevartuple_index </span><span class="s2">= </span><span class="s1">params</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">tvt</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">params</span><span class="s2">[</span><span class="s1">typevartuple_index </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">:]:</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">param</span><span class="s2">, </span><span class="s1">TypeVarTuple</span><span class="s2">):</span>
                        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                            <span class="s4">f&quot;More than one TypeVarTuple parameter in </span><span class="s0">{</span><span class="s1">alias</span><span class="s0">}</span><span class="s4">&quot;</span>
                        <span class="s2">)</span>

                <span class="s1">alen </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
                <span class="s1">plen </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">)</span>
                <span class="s1">left </span><span class="s2">= </span><span class="s1">typevartuple_index</span>
                <span class="s1">right </span><span class="s2">= </span><span class="s1">plen </span><span class="s2">- </span><span class="s1">typevartuple_index </span><span class="s2">- </span><span class="s5">1</span>
                <span class="s1">var_tuple_index </span><span class="s2">= </span><span class="s0">None</span>
                <span class="s1">fillarg </span><span class="s2">= </span><span class="s0">None</span>
                <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">args</span><span class="s2">):</span>
                    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
                        <span class="s1">subargs </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s4">'__typing_unpacked_tuple_args__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                        <span class="s0">if </span><span class="s1">subargs </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">subargs</span><span class="s2">) == </span><span class="s5">2 </span><span class="s0">and </span><span class="s1">subargs</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] </span><span class="s0">is </span><span class="s2">...:</span>
                            <span class="s0">if </span><span class="s1">var_tuple_index </span><span class="s0">is not None</span><span class="s2">:</span>
                                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                                    <span class="s4">&quot;More than one unpacked &quot;</span>
                                    <span class="s4">&quot;arbitrary-length tuple argument&quot;</span>
                                <span class="s2">)</span>
                            <span class="s1">var_tuple_index </span><span class="s2">= </span><span class="s1">k</span>
                            <span class="s1">fillarg </span><span class="s2">= </span><span class="s1">subargs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">var_tuple_index </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">left </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">var_tuple_index</span><span class="s2">)</span>
                    <span class="s1">right </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">right</span><span class="s2">, </span><span class="s1">alen </span><span class="s2">- </span><span class="s1">var_tuple_index </span><span class="s2">- </span><span class="s5">1</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">left </span><span class="s2">+ </span><span class="s1">right </span><span class="s2">&gt; </span><span class="s1">alen</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Too few arguments for </span><span class="s0">{</span><span class="s1">alias</span><span class="s0">}</span><span class="s4">;&quot;</span>
                                    <span class="s4">f&quot; actual </span><span class="s0">{</span><span class="s1">alen</span><span class="s0">}</span><span class="s4">, expected at least </span><span class="s0">{</span><span class="s1">plen </span><span class="s2">- </span><span class="s5">1</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">left </span><span class="s2">== </span><span class="s1">alen </span><span class="s2">- </span><span class="s1">right </span><span class="s0">and </span><span class="s1">tvt</span><span class="s2">.</span><span class="s1">has_default</span><span class="s2">():</span>
                    <span class="s1">replacement </span><span class="s2">= </span><span class="s1">_unpack_args</span><span class="s2">(</span><span class="s1">tvt</span><span class="s2">.</span><span class="s1">__default__</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">replacement </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s1">left</span><span class="s2">: </span><span class="s1">alen </span><span class="s2">- </span><span class="s1">right</span><span class="s2">]</span>

                <span class="s0">return </span><span class="s2">(</span>
                    <span class="s2">*</span><span class="s1">args</span><span class="s2">[:</span><span class="s1">left</span><span class="s2">],</span>
                    <span class="s2">*([</span><span class="s1">fillarg</span><span class="s2">] * (</span><span class="s1">typevartuple_index </span><span class="s2">- </span><span class="s1">left</span><span class="s2">)),</span>
                    <span class="s1">replacement</span><span class="s2">,</span>
                    <span class="s2">*([</span><span class="s1">fillarg</span><span class="s2">] * (</span><span class="s1">plen </span><span class="s2">- </span><span class="s1">right </span><span class="s2">- </span><span class="s1">left </span><span class="s2">- </span><span class="s1">typevartuple_index </span><span class="s2">- </span><span class="s5">1</span><span class="s2">)),</span>
                    <span class="s2">*</span><span class="s1">args</span><span class="s2">[</span><span class="s1">alen </span><span class="s2">- </span><span class="s1">right</span><span class="s2">:],</span>
                <span class="s2">)</span>

            <span class="s1">tvt</span><span class="s2">.</span><span class="s1">__typing_prepare_subst__ </span><span class="s2">= </span><span class="s1">_typevartuple_prepare_subst</span>
            <span class="s0">return </span><span class="s1">tvt</span>

        <span class="s0">def </span><span class="s1">__init_subclass__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Cannot subclass special typing classes&quot;</span><span class="s2">)</span>

<span class="s0">else</span><span class="s2">:  </span><span class="s3"># &lt;=3.10</span>
    <span class="s0">class </span><span class="s1">TypeVarTuple</span><span class="s2">(</span><span class="s1">_DefaultMixin</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Type variable tuple. 
 
        Usage:: 
 
            Ts = TypeVarTuple('Ts') 
 
        In the same way that a normal type variable is a stand-in for a single 
        type such as ``int``, a type variable *tuple* is a stand-in for a *tuple* 
        type such as ``Tuple[int, str]``. 
 
        Type variable tuples can be used in ``Generic`` declarations. 
        Consider the following example:: 
 
            class Array(Generic[*Ts]): ... 
 
        The ``Ts`` type variable tuple here behaves like ``tuple[T1, T2]``, 
        where ``T1`` and ``T2`` are type variables. To use these type variables 
        as type parameters of ``Array``, we must *unpack* the type variable tuple using 
        the star operator: ``*Ts``. The signature of ``Array`` then behaves 
        as if we had simply written ``class Array(Generic[T1, T2]): ...``. 
        In contrast to ``Generic[T1, T2]``, however, ``Generic[*Shape]`` allows 
        us to parameterise the class with an *arbitrary* number of type parameters. 
 
        Type variable tuples can be used anywhere a normal ``TypeVar`` can. 
        This includes class definitions, as shown above, as well as function 
        signatures and variable annotations:: 
 
            class Array(Generic[*Ts]): 
 
                def __init__(self, shape: Tuple[*Ts]): 
                    self._shape: Tuple[*Ts] = shape 
 
                def get_shape(self) -&gt; Tuple[*Ts]: 
                    return self._shape 
 
            shape = (Height(480), Width(640)) 
            x: Array[Height, Width] = Array(shape) 
            y = abs(x)  # Inferred type is Array[Height, Width] 
            z = x + x   #        ...    is Array[Height, Width] 
            x.get_shape()  #     ...    is tuple[Height, Width] 
 
        &quot;&quot;&quot;</span>

        <span class="s3"># Trick Generic __parameters__.</span>
        <span class="s1">__class__ </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span>

        <span class="s0">def </span><span class="s1">__iter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">yield </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__unpacked__</span>

        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, *, </span><span class="s1">default</span><span class="s2">=</span><span class="s1">NoDefault</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s1">name</span>
            <span class="s1">_DefaultMixin</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">default</span><span class="s2">)</span>

            <span class="s3"># for pickling:</span>
            <span class="s1">def_mod </span><span class="s2">= </span><span class="s1">_caller</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">def_mod </span><span class="s2">!= </span><span class="s4">'typing_extensions'</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__module__ </span><span class="s2">= </span><span class="s1">def_mod</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">__unpacked__ </span><span class="s2">= </span><span class="s1">Unpack</span><span class="s2">[</span><span class="s1">self</span><span class="s2">]</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__name__</span>

        <span class="s0">def </span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

        <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__name__</span>

        <span class="s0">def </span><span class="s1">__init_subclass__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s4">'_root' </span><span class="s0">not in </span><span class="s1">kwds</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Cannot subclass special typing classes&quot;</span><span class="s2">)</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;reveal_type&quot;</span><span class="s2">):  </span><span class="s3"># 3.11+</span>
    <span class="s1">reveal_type </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">reveal_type</span>
<span class="s0">else</span><span class="s2">:  </span><span class="s3"># &lt;=3.10</span>
    <span class="s0">def </span><span class="s1">reveal_type</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, /) </span><span class="s1">-&gt; T</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Reveal the inferred type of a variable. 
 
        When a static type checker encounters a call to ``reveal_type()``, 
        it will emit the inferred type of the argument:: 
 
            x: int = 1 
            reveal_type(x) 
 
        Running a static type checker (e.g., ``mypy``) on this example 
        will produce output similar to 'Revealed type is &quot;builtins.int&quot;'. 
 
        At runtime, the function prints the runtime type of the 
        argument and returns it unchanged. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s4">f&quot;Runtime type is </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">stderr</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">obj</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;_ASSERT_NEVER_REPR_MAX_LENGTH&quot;</span><span class="s2">):  </span><span class="s3"># 3.11+</span>
    <span class="s1">_ASSERT_NEVER_REPR_MAX_LENGTH </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_ASSERT_NEVER_REPR_MAX_LENGTH</span>
<span class="s0">else</span><span class="s2">:  </span><span class="s3"># &lt;=3.10</span>
    <span class="s1">_ASSERT_NEVER_REPR_MAX_LENGTH </span><span class="s2">= </span><span class="s5">100</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;assert_never&quot;</span><span class="s2">):  </span><span class="s3"># 3.11+</span>
    <span class="s1">assert_never </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">assert_never</span>
<span class="s0">else</span><span class="s2">:  </span><span class="s3"># &lt;=3.10</span>
    <span class="s0">def </span><span class="s1">assert_never</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">: </span><span class="s1">Never</span><span class="s2">, /) </span><span class="s1">-&gt; Never</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Assert to the type checker that a line of code is unreachable. 
 
        Example:: 
 
            def int_or_str(arg: int | str) -&gt; None: 
                match arg: 
                    case int(): 
                        print(&quot;It's an int&quot;) 
                    case str(): 
                        print(&quot;It's a str&quot;) 
                    case _: 
                        assert_never(arg) 
 
        If a type checker finds that a call to assert_never() is 
        reachable, it will emit an error. 
 
        At runtime, this throws an exception when called. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">value</span><span class="s2">) &gt; </span><span class="s1">_ASSERT_NEVER_REPR_MAX_LENGTH</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">value</span><span class="s2">[:</span><span class="s1">_ASSERT_NEVER_REPR_MAX_LENGTH</span><span class="s2">] + </span><span class="s4">'...'</span>
        <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span><span class="s4">f&quot;Expected code to be unreachable, but got: </span><span class="s0">{</span><span class="s1">value</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>


<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">):  </span><span class="s3"># 3.12+</span>
    <span class="s3"># dataclass_transform exists in 3.11 but lacks the frozen_default parameter</span>
    <span class="s1">dataclass_transform </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">dataclass_transform</span>
<span class="s0">else</span><span class="s2">:  </span><span class="s3"># &lt;=3.11</span>
    <span class="s0">def </span><span class="s1">dataclass_transform</span><span class="s2">(</span>
        <span class="s2">*,</span>
        <span class="s1">eq_default</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">order_default</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">kw_only_default</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">frozen_default</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">field_specifiers</span><span class="s2">: </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Tuple</span><span class="s2">[</span>
            <span class="s1">typing</span><span class="s2">.</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Type</span><span class="s2">[</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]],</span>
            <span class="s2">...</span>
        <span class="s2">] = (),</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">: </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; typing</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">T</span><span class="s2">], </span><span class="s1">T</span><span class="s2">]:</span>
        <span class="s6">&quot;&quot;&quot;Decorator that marks a function, class, or metaclass as providing 
        dataclass-like behavior. 
 
        Example: 
 
            from pip._vendor.typing_extensions import dataclass_transform 
 
            _T = TypeVar(&quot;_T&quot;) 
 
            # Used on a decorator function 
            @dataclass_transform() 
            def create_model(cls: type[_T]) -&gt; type[_T]: 
                ... 
                return cls 
 
            @create_model 
            class CustomerModel: 
                id: int 
                name: str 
 
            # Used on a base class 
            @dataclass_transform() 
            class ModelBase: ... 
 
            class CustomerModel(ModelBase): 
                id: int 
                name: str 
 
            # Used on a metaclass 
            @dataclass_transform() 
            class ModelMeta(type): ... 
 
            class ModelBase(metaclass=ModelMeta): ... 
 
            class CustomerModel(ModelBase): 
                id: int 
                name: str 
 
        Each of the ``CustomerModel`` classes defined in this example will now 
        behave similarly to a dataclass created with the ``@dataclasses.dataclass`` 
        decorator. For example, the type checker will synthesize an ``__init__`` 
        method. 
 
        The arguments to this decorator can be used to customize this behavior: 
        - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be 
          True or False if it is omitted by the caller. 
        - ``order_default`` indicates whether the ``order`` parameter is 
          assumed to be True or False if it is omitted by the caller. 
        - ``kw_only_default`` indicates whether the ``kw_only`` parameter is 
          assumed to be True or False if it is omitted by the caller. 
        - ``frozen_default`` indicates whether the ``frozen`` parameter is 
          assumed to be True or False if it is omitted by the caller. 
        - ``field_specifiers`` specifies a static list of supported classes 
          or functions that describe fields, similar to ``dataclasses.field()``. 
 
        At runtime, this decorator records its arguments in the 
        ``__dataclass_transform__`` attribute on the decorated object. 
 
        See PEP 681 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">decorator</span><span class="s2">(</span><span class="s1">cls_or_fn</span><span class="s2">):</span>
            <span class="s1">cls_or_fn</span><span class="s2">.</span><span class="s1">__dataclass_transform__ </span><span class="s2">= {</span>
                <span class="s4">&quot;eq_default&quot;</span><span class="s2">: </span><span class="s1">eq_default</span><span class="s2">,</span>
                <span class="s4">&quot;order_default&quot;</span><span class="s2">: </span><span class="s1">order_default</span><span class="s2">,</span>
                <span class="s4">&quot;kw_only_default&quot;</span><span class="s2">: </span><span class="s1">kw_only_default</span><span class="s2">,</span>
                <span class="s4">&quot;frozen_default&quot;</span><span class="s2">: </span><span class="s1">frozen_default</span><span class="s2">,</span>
                <span class="s4">&quot;field_specifiers&quot;</span><span class="s2">: </span><span class="s1">field_specifiers</span><span class="s2">,</span>
                <span class="s4">&quot;kwargs&quot;</span><span class="s2">: </span><span class="s1">kwargs</span><span class="s2">,</span>
            <span class="s2">}</span>
            <span class="s0">return </span><span class="s1">cls_or_fn</span>
        <span class="s0">return </span><span class="s1">decorator</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;override&quot;</span><span class="s2">):  </span><span class="s3"># 3.12+</span>
    <span class="s1">override </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">override</span>
<span class="s0">else</span><span class="s2">:  </span><span class="s3"># &lt;=3.11</span>
    <span class="s1">_F </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s4">&quot;_F&quot;</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">override</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">: </span><span class="s1">_F</span><span class="s2">, /) </span><span class="s1">-&gt; _F</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Indicate that a method is intended to override a method in a base class. 
 
        Usage: 
 
            class Base: 
                def method(self) -&gt; None: 
                    pass 
 
            class Child(Base): 
                @override 
                def method(self) -&gt; None: 
                    super().method() 
 
        When this decorator is applied to a method, the type checker will 
        validate that it overrides a method with the same name on a base class. 
        This helps prevent bugs that may occur when a base class is changed 
        without an equivalent change to a child class. 
 
        There is no runtime checking of these properties. The decorator 
        sets the ``__override__`` attribute to ``True`` on the decorated object 
        to allow runtime introspection. 
 
        See PEP 698 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">arg</span><span class="s2">.</span><span class="s1">__override__ </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
            <span class="s3"># Skip the attribute silently if it is not writable.</span>
            <span class="s3"># AttributeError happens if the object has __slots__ or a</span>
            <span class="s3"># read-only property, TypeError if it's a builtin class.</span>
            <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">arg</span>


<span class="s3"># Python 3.13.3+ contains a fix for the wrapped __new__</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">3</span><span class="s2">):</span>
    <span class="s1">deprecated </span><span class="s2">= </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">deprecated</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s1">_T </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s4">&quot;_T&quot;</span><span class="s2">)</span>

    <span class="s0">class </span><span class="s1">deprecated</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Indicate that a class, function or overload is deprecated. 
 
        When this decorator is applied to an object, the type checker 
        will generate a diagnostic on usage of the deprecated object. 
 
        Usage: 
 
            @deprecated(&quot;Use B instead&quot;) 
            class A: 
                pass 
 
            @deprecated(&quot;Use g instead&quot;) 
            def f(): 
                pass 
 
            @overload 
            @deprecated(&quot;int support is deprecated&quot;) 
            def g(x: int) -&gt; int: ... 
            @overload 
            def g(x: str) -&gt; int: ... 
 
        The warning specified by *category* will be emitted at runtime 
        on use of deprecated objects. For functions, that happens on calls; 
        for classes, on instantiation and on creation of subclasses. 
        If the *category* is ``None``, no warning is emitted at runtime. 
        The *stacklevel* determines where the 
        warning is emitted. If it is ``1`` (the default), the warning 
        is emitted at the direct caller of the deprecated object; if it 
        is higher, it is emitted further up the stack. 
        Static type checker behavior is not affected by the *category* 
        and *stacklevel* arguments. 
 
        The deprecation message passed to the decorator is saved in the 
        ``__deprecated__`` attribute on the decorated object. 
        If applied to an overload, the decorator 
        must be after the ``@overload`` decorator for the attribute to 
        exist on the overload as returned by ``get_overloads()``. 
 
        See PEP 702 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">message</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
            <span class="s2">/,</span>
            <span class="s2">*,</span>
            <span class="s1">category</span><span class="s2">: </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Type</span><span class="s2">[</span><span class="s1">Warning</span><span class="s2">]] = </span><span class="s1">DeprecationWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s5">1</span><span class="s2">,</span>
        <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                    <span class="s4">&quot;Expected an object of type str for 'message', not &quot;</span>
                    <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">message</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">!r}</span><span class="s4">&quot;</span>
                <span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">message </span><span class="s2">= </span><span class="s1">message</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">category </span><span class="s2">= </span><span class="s1">category</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">stacklevel </span><span class="s2">= </span><span class="s1">stacklevel</span>

        <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">: </span><span class="s1">_T</span><span class="s2">, /) </span><span class="s1">-&gt; _T</span><span class="s2">:</span>
            <span class="s3"># Make sure the inner functions created below don't</span>
            <span class="s3"># retain a reference to self.</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">message</span>
            <span class="s1">category </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">category</span>
            <span class="s1">stacklevel </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">stacklevel</span>
            <span class="s0">if </span><span class="s1">category </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">arg</span><span class="s2">.</span><span class="s1">__deprecated__ </span><span class="s2">= </span><span class="s1">msg</span>
                <span class="s0">return </span><span class="s1">arg</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
                <span class="s0">import </span><span class="s1">functools</span>
                <span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">MethodType</span>

                <span class="s1">original_new </span><span class="s2">= </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">__new__</span>

                <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">original_new</span><span class="s2">)</span>
                <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, /, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">arg</span><span class="s2">:</span>
                        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">category</span><span class="s2">=</span><span class="s1">category</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">stacklevel </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">original_new </span><span class="s0">is not </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">original_new</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                    <span class="s3"># Mirrors a similar check in object.__new__.</span>
                    <span class="s0">elif </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__init__ </span><span class="s0">is </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__init__ </span><span class="s0">and </span><span class="s2">(</span><span class="s1">args </span><span class="s0">or </span><span class="s1">kwargs</span><span class="s2">):</span>
                        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">() takes no arguments&quot;</span><span class="s2">)</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">original_new</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">)</span>

                <span class="s1">arg</span><span class="s2">.</span><span class="s1">__new__ </span><span class="s2">= </span><span class="s1">staticmethod</span><span class="s2">(</span><span class="s1">__new__</span><span class="s2">)</span>

                <span class="s1">original_init_subclass </span><span class="s2">= </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">__init_subclass__</span>
                <span class="s3"># We need slightly different behavior if __init_subclass__</span>
                <span class="s3"># is a bound method (likely if it was implemented in Python)</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">original_init_subclass</span><span class="s2">, </span><span class="s1">MethodType</span><span class="s2">):</span>
                    <span class="s1">original_init_subclass </span><span class="s2">= </span><span class="s1">original_init_subclass</span><span class="s2">.</span><span class="s1">__func__</span>

                    <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">original_init_subclass</span><span class="s2">)</span>
                    <span class="s0">def </span><span class="s1">__init_subclass__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
                        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">category</span><span class="s2">=</span><span class="s1">category</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">stacklevel </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
                        <span class="s0">return </span><span class="s1">original_init_subclass</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

                    <span class="s1">arg</span><span class="s2">.</span><span class="s1">__init_subclass__ </span><span class="s2">= </span><span class="s1">classmethod</span><span class="s2">(</span><span class="s1">__init_subclass__</span><span class="s2">)</span>
                <span class="s3"># Or otherwise, which likely means it's a builtin such as</span>
                <span class="s3"># object's implementation of __init_subclass__.</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">original_init_subclass</span><span class="s2">)</span>
                    <span class="s0">def </span><span class="s1">__init_subclass__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
                        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">category</span><span class="s2">=</span><span class="s1">category</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">stacklevel </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
                        <span class="s0">return </span><span class="s1">original_init_subclass</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

                    <span class="s1">arg</span><span class="s2">.</span><span class="s1">__init_subclass__ </span><span class="s2">= </span><span class="s1">__init_subclass__</span>

                <span class="s1">arg</span><span class="s2">.</span><span class="s1">__deprecated__ </span><span class="s2">= </span><span class="s1">__new__</span><span class="s2">.</span><span class="s1">__deprecated__ </span><span class="s2">= </span><span class="s1">msg</span>
                <span class="s1">__init_subclass__</span><span class="s2">.</span><span class="s1">__deprecated__ </span><span class="s2">= </span><span class="s1">msg</span>
                <span class="s0">return </span><span class="s1">arg</span>
            <span class="s0">elif </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">):</span>
                <span class="s0">import </span><span class="s1">asyncio</span><span class="s2">.</span><span class="s1">coroutines</span>
                <span class="s0">import </span><span class="s1">functools</span>
                <span class="s0">import </span><span class="s1">inspect</span>

                <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
                <span class="s0">def </span><span class="s1">wrapper</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
                    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">category</span><span class="s2">=</span><span class="s1">category</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">stacklevel </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">arg</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

                <span class="s0">if </span><span class="s1">asyncio</span><span class="s2">.</span><span class="s1">coroutines</span><span class="s2">.</span><span class="s1">iscoroutinefunction</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">):</span>
                        <span class="s1">wrapper </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">markcoroutinefunction</span><span class="s2">(</span><span class="s1">wrapper</span><span class="s2">)</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s1">wrapper</span><span class="s2">.</span><span class="s1">_is_coroutine </span><span class="s2">= </span><span class="s1">asyncio</span><span class="s2">.</span><span class="s1">coroutines</span><span class="s2">.</span><span class="s1">_is_coroutine</span>

                <span class="s1">arg</span><span class="s2">.</span><span class="s1">__deprecated__ </span><span class="s2">= </span><span class="s1">wrapper</span><span class="s2">.</span><span class="s1">__deprecated__ </span><span class="s2">= </span><span class="s1">msg</span>
                <span class="s0">return </span><span class="s1">wrapper</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                    <span class="s4">&quot;@deprecated decorator with non-None category must be applied to &quot;</span>
                    <span class="s4">f&quot;a class or callable, not </span><span class="s0">{</span><span class="s1">arg</span><span class="s0">!r}</span><span class="s4">&quot;</span>
                <span class="s2">)</span>

<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">_is_param_expr</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">arg </span><span class="s0">is </span><span class="s2">... </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span>
            <span class="s1">arg</span><span class="s2">, (</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">list</span><span class="s2">, </span><span class="s1">ParamSpec</span><span class="s2">, </span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">)</span>
        <span class="s2">)</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">_is_param_expr</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">arg </span><span class="s0">is </span><span class="s2">... </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span>
            <span class="s1">arg</span><span class="s2">,</span>
            <span class="s2">(</span>
                <span class="s1">tuple</span><span class="s2">,</span>
                <span class="s1">list</span><span class="s2">,</span>
                <span class="s1">ParamSpec</span><span class="s2">,</span>
                <span class="s1">_ConcatenateGenericAlias</span><span class="s2">,</span>
                <span class="s1">typing</span><span class="s2">.</span><span class="s1">_ConcatenateGenericAlias</span><span class="s2">,</span>
            <span class="s2">),</span>
        <span class="s2">)</span>


<span class="s3"># We have to do some monkey patching to deal with the dual nature of</span>
<span class="s3"># Unpack/TypeVarTuple:</span>
<span class="s3"># - We want Unpack to be a kind of TypeVar so it gets accepted in</span>
<span class="s3">#   Generic[Unpack[Ts]]</span>
<span class="s3"># - We want it to *not* be treated as a TypeVar for the purposes of</span>
<span class="s3">#   counting generic parameters, so that when we subscript a generic,</span>
<span class="s3">#   the runtime doesn't try to substitute the Unpack with the subscripted type.</span>
<span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;TypeVarTuple&quot;</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">_check_generic</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">elen</span><span class="s2">=</span><span class="s1">_marker</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Check correct count for parameters of a generic cls (internal helper). 
 
        This gives a nice error message in case of count mismatch. 
        &quot;&quot;&quot;</span>
        <span class="s3"># If substituting a single ParamSpec with multiple arguments</span>
        <span class="s3"># we do not check the count</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">isclass</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">) </span><span class="s0">and </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__parameters__</span><span class="s2">) == </span><span class="s5">1</span>
            <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__parameters__</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">ParamSpec</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">parameters</span>
            <span class="s0">and not </span><span class="s1">_is_param_expr</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
        <span class="s2">):</span>
            <span class="s3"># Generic modifies parameters variable, but here we cannot do this</span>
            <span class="s0">return</span>

        <span class="s0">if not </span><span class="s1">elen</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">} </span><span class="s4">is not a generic class&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">elen </span><span class="s0">is </span><span class="s1">_marker</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s4">&quot;__parameters__&quot;</span><span class="s2">) </span><span class="s0">or not </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__parameters__</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">} </span><span class="s4">is not a generic class&quot;</span><span class="s2">)</span>
            <span class="s1">elen </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__parameters__</span><span class="s2">)</span>
        <span class="s1">alen </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">alen </span><span class="s2">!= </span><span class="s1">elen</span><span class="s2">:</span>
            <span class="s1">expect_val </span><span class="s2">= </span><span class="s1">elen</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s4">&quot;__parameters__&quot;</span><span class="s2">):</span>
                <span class="s1">parameters </span><span class="s2">= [</span><span class="s1">p </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__parameters__ </span><span class="s0">if not </span><span class="s1">_is_unpack</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)]</span>
                <span class="s1">num_tv_tuples </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">TypeVarTuple</span><span class="s2">) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s2">(</span><span class="s1">num_tv_tuples </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s1">alen </span><span class="s2">&gt;= </span><span class="s1">elen </span><span class="s2">- </span><span class="s1">num_tv_tuples</span><span class="s2">):</span>
                    <span class="s0">return</span>

                <span class="s3"># deal with TypeVarLike defaults</span>
                <span class="s3"># required TypeVarLikes cannot appear after a defaulted one.</span>
                <span class="s0">if </span><span class="s1">alen </span><span class="s2">&lt; </span><span class="s1">elen</span><span class="s2">:</span>
                    <span class="s3"># since we validate TypeVarLike default in _collect_type_vars</span>
                    <span class="s3"># or _collect_parameters we can safely check parameters[alen]</span>
                    <span class="s0">if </span><span class="s2">(</span>
                        <span class="s1">getattr</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">[</span><span class="s1">alen</span><span class="s2">], </span><span class="s4">'__default__'</span><span class="s2">, </span><span class="s1">NoDefault</span><span class="s2">)</span>
                        <span class="s0">is not </span><span class="s1">NoDefault</span>
                    <span class="s2">):</span>
                        <span class="s0">return</span>

                    <span class="s1">num_default_tv </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s4">'__default__'</span><span class="s2">, </span><span class="s1">NoDefault</span><span class="s2">)</span>
                                         <span class="s0">is not </span><span class="s1">NoDefault </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters</span><span class="s2">)</span>

                    <span class="s1">elen </span><span class="s2">-= </span><span class="s1">num_default_tv</span>

                    <span class="s1">expect_val </span><span class="s2">= </span><span class="s4">f&quot;at least </span><span class="s0">{</span><span class="s1">elen</span><span class="s0">}</span><span class="s4">&quot;</span>

            <span class="s1">things </span><span class="s2">= </span><span class="s4">&quot;arguments&quot; </span><span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">) </span><span class="s0">else </span><span class="s4">&quot;parameters&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Too </span><span class="s0">{</span><span class="s4">'many' </span><span class="s0">if </span><span class="s1">alen </span><span class="s2">&gt; </span><span class="s1">elen </span><span class="s0">else </span><span class="s4">'few'</span><span class="s0">} {</span><span class="s1">things</span><span class="s0">}</span><span class="s4">&quot;</span>
                            <span class="s4">f&quot; for </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s4">; actual </span><span class="s0">{</span><span class="s1">alen</span><span class="s0">}</span><span class="s4">, expected </span><span class="s0">{</span><span class="s1">expect_val</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s3"># Python 3.11+</span>

    <span class="s0">def </span><span class="s1">_check_generic</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">elen</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Check correct count for parameters of a generic cls (internal helper). 
 
        This gives a nice error message in case of count mismatch. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">elen</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">} </span><span class="s4">is not a generic class&quot;</span><span class="s2">)</span>
        <span class="s1">alen </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">alen </span><span class="s2">!= </span><span class="s1">elen</span><span class="s2">:</span>
            <span class="s1">expect_val </span><span class="s2">= </span><span class="s1">elen</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s4">&quot;__parameters__&quot;</span><span class="s2">):</span>
                <span class="s1">parameters </span><span class="s2">= [</span><span class="s1">p </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__parameters__ </span><span class="s0">if not </span><span class="s1">_is_unpack</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)]</span>

                <span class="s3"># deal with TypeVarLike defaults</span>
                <span class="s3"># required TypeVarLikes cannot appear after a defaulted one.</span>
                <span class="s0">if </span><span class="s1">alen </span><span class="s2">&lt; </span><span class="s1">elen</span><span class="s2">:</span>
                    <span class="s3"># since we validate TypeVarLike default in _collect_type_vars</span>
                    <span class="s3"># or _collect_parameters we can safely check parameters[alen]</span>
                    <span class="s0">if </span><span class="s2">(</span>
                        <span class="s1">getattr</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">[</span><span class="s1">alen</span><span class="s2">], </span><span class="s4">'__default__'</span><span class="s2">, </span><span class="s1">NoDefault</span><span class="s2">)</span>
                        <span class="s0">is not </span><span class="s1">NoDefault</span>
                    <span class="s2">):</span>
                        <span class="s0">return</span>

                    <span class="s1">num_default_tv </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s4">'__default__'</span><span class="s2">, </span><span class="s1">NoDefault</span><span class="s2">)</span>
                                         <span class="s0">is not </span><span class="s1">NoDefault </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters</span><span class="s2">)</span>

                    <span class="s1">elen </span><span class="s2">-= </span><span class="s1">num_default_tv</span>

                    <span class="s1">expect_val </span><span class="s2">= </span><span class="s4">f&quot;at least </span><span class="s0">{</span><span class="s1">elen</span><span class="s0">}</span><span class="s4">&quot;</span>

            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Too </span><span class="s0">{</span><span class="s4">'many' </span><span class="s0">if </span><span class="s1">alen </span><span class="s2">&gt; </span><span class="s1">elen </span><span class="s0">else </span><span class="s4">'few'</span><span class="s0">} </span><span class="s4">arguments&quot;</span>
                            <span class="s4">f&quot; for </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s4">; actual </span><span class="s0">{</span><span class="s1">alen</span><span class="s0">}</span><span class="s4">, expected </span><span class="s0">{</span><span class="s1">expect_val</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>

<span class="s0">if not </span><span class="s1">_PEP_696_IMPLEMENTED</span><span class="s2">:</span>
    <span class="s1">typing</span><span class="s2">.</span><span class="s1">_check_generic </span><span class="s2">= </span><span class="s1">_check_generic</span>


<span class="s0">def </span><span class="s1">_has_generic_or_protocol_as_origin</span><span class="s2">() </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">frame </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">_getframe</span><span class="s2">(</span><span class="s5">2</span><span class="s2">)</span>
    <span class="s3"># - Catch AttributeError: not all Python implementations have sys._getframe()</span>
    <span class="s3"># - Catch ValueError: maybe we're called from an unexpected module</span>
    <span class="s3">#   and the call stack isn't deep enough</span>
    <span class="s0">except </span><span class="s2">(</span><span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">):</span>
        <span class="s0">return False  </span><span class="s3"># err on the side of leniency</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s3"># If we somehow get invoked from outside typing.py,</span>
        <span class="s3"># also err on the side of leniency</span>
        <span class="s0">if </span><span class="s1">frame</span><span class="s2">.</span><span class="s1">f_globals</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;__name__&quot;</span><span class="s2">) != </span><span class="s4">&quot;typing&quot;</span><span class="s2">:</span>
            <span class="s0">return False</span>
        <span class="s1">origin </span><span class="s2">= </span><span class="s1">frame</span><span class="s2">.</span><span class="s1">f_locals</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;origin&quot;</span><span class="s2">)</span>
        <span class="s3"># Cannot use &quot;in&quot; because origin may be an object with a buggy __eq__ that</span>
        <span class="s3"># throws an error.</span>
        <span class="s0">return </span><span class="s1">origin </span><span class="s0">is </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic </span><span class="s0">or </span><span class="s1">origin </span><span class="s0">is </span><span class="s1">Protocol </span><span class="s0">or </span><span class="s1">origin </span><span class="s0">is </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Protocol</span>


<span class="s1">_TYPEVARTUPLE_TYPES </span><span class="s2">= {</span><span class="s1">TypeVarTuple</span><span class="s2">, </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;TypeVarTuple&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)}</span>


<span class="s0">def </span><span class="s1">_is_unpacked_typevartuple</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">is not </span><span class="s1">Unpack</span><span class="s2">:</span>
        <span class="s0">return False</span>
    <span class="s1">args </span><span class="s2">= </span><span class="s1">get_args</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s2">(</span>
        <span class="s1">bool</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) == </span><span class="s5">1</span>
        <span class="s0">and </span><span class="s1">type</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]) </span><span class="s0">in </span><span class="s1">_TYPEVARTUPLE_TYPES</span>
    <span class="s2">)</span>


<span class="s3"># Python 3.11+ _collect_type_vars was renamed to _collect_parameters</span>
<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'_collect_type_vars'</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">_collect_type_vars</span><span class="s2">(</span><span class="s1">types</span><span class="s2">, </span><span class="s1">typevar_types</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Collect all type variable contained in types in order of 
        first appearance (lexicographic order). For example:: 
 
            _collect_type_vars((T, List[S, T])) == (T, S) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">typevar_types </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">typevar_types </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeVar</span>
        <span class="s1">tvars </span><span class="s2">= []</span>

        <span class="s3"># A required TypeVarLike cannot appear after a TypeVarLike with a default</span>
        <span class="s3"># if it was a direct call to `Generic[]` or `Protocol[]`</span>
        <span class="s1">enforce_default_ordering </span><span class="s2">= </span><span class="s1">_has_generic_or_protocol_as_origin</span><span class="s2">()</span>
        <span class="s1">default_encountered </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s3"># Also, a TypeVarLike with a default cannot appear after a TypeVarTuple</span>
        <span class="s1">type_var_tuple_encountered </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">_is_unpacked_typevartuple</span><span class="s2">(</span><span class="s1">t</span><span class="s2">):</span>
                <span class="s1">type_var_tuple_encountered </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s2">(</span>
                <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">typevar_types</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">_UnpackAlias</span><span class="s2">)</span>
                <span class="s0">and </span><span class="s1">t </span><span class="s0">not in </span><span class="s1">tvars</span>
            <span class="s2">):</span>
                <span class="s0">if </span><span class="s1">enforce_default_ordering</span><span class="s2">:</span>
                    <span class="s1">has_default </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s4">'__default__'</span><span class="s2">, </span><span class="s1">NoDefault</span><span class="s2">) </span><span class="s0">is not </span><span class="s1">NoDefault</span>
                    <span class="s0">if </span><span class="s1">has_default</span><span class="s2">:</span>
                        <span class="s0">if </span><span class="s1">type_var_tuple_encountered</span><span class="s2">:</span>
                            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">'Type parameter with a default'</span>
                                            <span class="s4">' follows TypeVarTuple'</span><span class="s2">)</span>
                        <span class="s1">default_encountered </span><span class="s2">= </span><span class="s0">True</span>
                    <span class="s0">elif </span><span class="s1">default_encountered</span><span class="s2">:</span>
                        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f'Type parameter </span><span class="s0">{</span><span class="s1">t</span><span class="s0">!r} </span><span class="s4">without a default'</span>
                                        <span class="s4">' follows type parameter with a default'</span><span class="s2">)</span>

                <span class="s1">tvars</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">_should_collect_from_parameters</span><span class="s2">(</span><span class="s1">t</span><span class="s2">):</span>
                <span class="s1">tvars</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">([</span><span class="s1">t </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">t</span><span class="s2">.</span><span class="s1">__parameters__ </span><span class="s0">if </span><span class="s1">t </span><span class="s0">not in </span><span class="s1">tvars</span><span class="s2">])</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s3"># Collect nested type_vars</span>
                <span class="s3"># tuple wrapped by  _prepare_paramspec_params(cls, params)</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">t</span><span class="s2">:</span>
                    <span class="s0">for </span><span class="s1">collected </span><span class="s0">in </span><span class="s1">_collect_type_vars</span><span class="s2">([</span><span class="s1">x</span><span class="s2">]):</span>
                        <span class="s0">if </span><span class="s1">collected </span><span class="s0">not in </span><span class="s1">tvars</span><span class="s2">:</span>
                            <span class="s1">tvars</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">collected</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">tvars</span><span class="s2">)</span>

    <span class="s1">typing</span><span class="s2">.</span><span class="s1">_collect_type_vars </span><span class="s2">= </span><span class="s1">_collect_type_vars</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">_collect_parameters</span><span class="s2">(</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Collect all type variables and parameter specifications in args 
        in order of first appearance (lexicographic order). 
 
        For example:: 
 
            assert _collect_parameters((T, Callable[P, T])) == (T, P) 
        &quot;&quot;&quot;</span>
        <span class="s1">parameters </span><span class="s2">= []</span>

        <span class="s3"># A required TypeVarLike cannot appear after a TypeVarLike with default</span>
        <span class="s3"># if it was a direct call to `Generic[]` or `Protocol[]`</span>
        <span class="s1">enforce_default_ordering </span><span class="s2">= </span><span class="s1">_has_generic_or_protocol_as_origin</span><span class="s2">()</span>
        <span class="s1">default_encountered </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s3"># Also, a TypeVarLike with a default cannot appear after a TypeVarTuple</span>
        <span class="s1">type_var_tuple_encountered </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">args</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
                <span class="s3"># We don't want __parameters__ descriptor of a bare Python class.</span>
                <span class="s0">pass</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s3"># `t` might be a tuple, when `ParamSpec` is substituted with</span>
                <span class="s3"># `[T, int]`, or `[int, *Ts]`, etc.</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">t</span><span class="s2">:</span>
                    <span class="s0">for </span><span class="s1">collected </span><span class="s0">in </span><span class="s1">_collect_parameters</span><span class="s2">([</span><span class="s1">x</span><span class="s2">]):</span>
                        <span class="s0">if </span><span class="s1">collected </span><span class="s0">not in </span><span class="s1">parameters</span><span class="s2">:</span>
                            <span class="s1">parameters</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">collected</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s4">'__typing_subst__'</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">t </span><span class="s0">not in </span><span class="s1">parameters</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">enforce_default_ordering</span><span class="s2">:</span>
                        <span class="s1">has_default </span><span class="s2">= (</span>
                            <span class="s1">getattr</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s4">'__default__'</span><span class="s2">, </span><span class="s1">NoDefault</span><span class="s2">) </span><span class="s0">is not </span><span class="s1">NoDefault</span>
                        <span class="s2">)</span>

                        <span class="s0">if </span><span class="s1">type_var_tuple_encountered </span><span class="s0">and </span><span class="s1">has_default</span><span class="s2">:</span>
                            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">'Type parameter with a default'</span>
                                            <span class="s4">' follows TypeVarTuple'</span><span class="s2">)</span>

                        <span class="s0">if </span><span class="s1">has_default</span><span class="s2">:</span>
                            <span class="s1">default_encountered </span><span class="s2">= </span><span class="s0">True</span>
                        <span class="s0">elif </span><span class="s1">default_encountered</span><span class="s2">:</span>
                            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f'Type parameter </span><span class="s0">{</span><span class="s1">t</span><span class="s0">!r} </span><span class="s4">without a default'</span>
                                            <span class="s4">' follows type parameter with a default'</span><span class="s2">)</span>

                    <span class="s1">parameters</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">_is_unpacked_typevartuple</span><span class="s2">(</span><span class="s1">t</span><span class="s2">):</span>
                    <span class="s1">type_var_tuple_encountered </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s4">'__parameters__'</span><span class="s2">, ()):</span>
                    <span class="s0">if </span><span class="s1">x </span><span class="s0">not in </span><span class="s1">parameters</span><span class="s2">:</span>
                        <span class="s1">parameters</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">_PEP_696_IMPLEMENTED</span><span class="s2">:</span>
        <span class="s1">typing</span><span class="s2">.</span><span class="s1">_collect_parameters </span><span class="s2">= </span><span class="s1">_collect_parameters</span>

<span class="s3"># Backport typing.NamedTuple as it exists in Python 3.13.</span>
<span class="s3"># In 3.11, the ability to define generic `NamedTuple`s was supported.</span>
<span class="s3"># This was explicitly disallowed in 3.9-3.10, and only half-worked in &lt;=3.8.</span>
<span class="s3"># On 3.12, we added __orig_bases__ to call-based NamedTuples</span>
<span class="s3"># On 3.13, we deprecated kwargs-based NamedTuples</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">13</span><span class="s2">):</span>
    <span class="s1">NamedTuple </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">NamedTuple</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">_make_nmtuple</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">types</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">defaults</span><span class="s2">=()):</span>
        <span class="s1">fields </span><span class="s2">= [</span><span class="s1">n </span><span class="s0">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types</span><span class="s2">]</span>
        <span class="s1">annotations </span><span class="s2">= {</span><span class="s1">n</span><span class="s2">: </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s4">f&quot;field </span><span class="s0">{</span><span class="s1">n</span><span class="s0">} </span><span class="s4">annotation must be a type&quot;</span><span class="s2">)</span>
                       <span class="s0">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types</span><span class="s2">}</span>
        <span class="s1">nm_tpl </span><span class="s2">= </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">namedtuple</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">fields</span><span class="s2">,</span>
                                        <span class="s1">defaults</span><span class="s2">=</span><span class="s1">defaults</span><span class="s2">, </span><span class="s1">module</span><span class="s2">=</span><span class="s1">module</span><span class="s2">)</span>
        <span class="s1">nm_tpl</span><span class="s2">.</span><span class="s1">__annotations__ </span><span class="s2">= </span><span class="s1">nm_tpl</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">.</span><span class="s1">__annotations__ </span><span class="s2">= </span><span class="s1">annotations</span>
        <span class="s3"># The `_field_types` attribute was removed in 3.9;</span>
        <span class="s3"># in earlier versions, it is the same as the `__annotations__` attribute</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
            <span class="s1">nm_tpl</span><span class="s2">.</span><span class="s1">_field_types </span><span class="s2">= </span><span class="s1">annotations</span>
        <span class="s0">return </span><span class="s1">nm_tpl</span>

    <span class="s1">_prohibited_namedtuple_fields </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_prohibited</span>
    <span class="s1">_special_namedtuple_fields </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">({</span><span class="s4">'__module__'</span><span class="s2">, </span><span class="s4">'__name__'</span><span class="s2">, </span><span class="s4">'__annotations__'</span><span class="s2">})</span>

    <span class="s0">class </span><span class="s1">_NamedTupleMeta</span><span class="s2">(</span><span class="s1">type</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">typename</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">, </span><span class="s1">ns</span><span class="s2">):</span>
            <span class="s0">assert </span><span class="s1">_NamedTuple </span><span class="s0">in </span><span class="s1">bases</span>
            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">base </span><span class="s0">is not </span><span class="s1">_NamedTuple </span><span class="s0">and </span><span class="s1">base </span><span class="s0">is not </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                        <span class="s4">'can only inherit from a NamedTuple type and Generic'</span><span class="s2">)</span>
            <span class="s1">bases </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">tuple </span><span class="s0">if </span><span class="s1">base </span><span class="s0">is </span><span class="s1">_NamedTuple </span><span class="s0">else </span><span class="s1">base </span><span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s4">&quot;__annotations__&quot; </span><span class="s0">in </span><span class="s1">ns</span><span class="s2">:</span>
                <span class="s1">types </span><span class="s2">= </span><span class="s1">ns</span><span class="s2">[</span><span class="s4">&quot;__annotations__&quot;</span><span class="s2">]</span>
            <span class="s0">elif </span><span class="s4">&quot;__annotate__&quot; </span><span class="s0">in </span><span class="s1">ns</span><span class="s2">:</span>
                <span class="s3"># TODO: Use inspect.VALUE here, and make the annotations lazily evaluated</span>
                <span class="s1">types </span><span class="s2">= </span><span class="s1">ns</span><span class="s2">[</span><span class="s4">&quot;__annotate__&quot;</span><span class="s2">](</span><span class="s5">1</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">types </span><span class="s2">= {}</span>
            <span class="s1">default_names </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">field_name </span><span class="s0">in </span><span class="s1">types</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">field_name </span><span class="s0">in </span><span class="s1">ns</span><span class="s2">:</span>
                    <span class="s1">default_names</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">field_name</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">default_names</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Non-default namedtuple field </span><span class="s0">{</span><span class="s1">field_name</span><span class="s0">} </span><span class="s4">&quot;</span>
                                    <span class="s4">f&quot;cannot follow default field&quot;</span>
                                    <span class="s4">f&quot;</span><span class="s0">{</span><span class="s4">'s' </span><span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">default_names</span><span class="s2">) &gt; </span><span class="s5">1 </span><span class="s0">else </span><span class="s4">''</span><span class="s0">} </span><span class="s4">&quot;</span>
                                    <span class="s4">f&quot;</span><span class="s0">{</span><span class="s4">', '</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">default_names</span><span class="s2">)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
            <span class="s1">nm_tpl </span><span class="s2">= </span><span class="s1">_make_nmtuple</span><span class="s2">(</span>
                <span class="s1">typename</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">items</span><span class="s2">(),</span>
                <span class="s1">defaults</span><span class="s2">=[</span><span class="s1">ns</span><span class="s2">[</span><span class="s1">n</span><span class="s2">] </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">default_names</span><span class="s2">],</span>
                <span class="s1">module</span><span class="s2">=</span><span class="s1">ns</span><span class="s2">[</span><span class="s4">'__module__'</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">nm_tpl</span><span class="s2">.</span><span class="s1">__bases__ </span><span class="s2">= </span><span class="s1">bases</span>
            <span class="s0">if </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic </span><span class="s0">in </span><span class="s1">bases</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">'_generic_class_getitem'</span><span class="s2">):  </span><span class="s3"># 3.12+</span>
                    <span class="s1">nm_tpl</span><span class="s2">.</span><span class="s1">__class_getitem__ </span><span class="s2">= </span><span class="s1">classmethod</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_generic_class_getitem</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">class_getitem </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span><span class="s2">.</span><span class="s1">__class_getitem__</span><span class="s2">.</span><span class="s1">__func__</span>
                    <span class="s1">nm_tpl</span><span class="s2">.</span><span class="s1">__class_getitem__ </span><span class="s2">= </span><span class="s1">classmethod</span><span class="s2">(</span><span class="s1">class_getitem</span><span class="s2">)</span>
            <span class="s3"># update from user namespace without overriding special namedtuple attributes</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">ns</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">_prohibited_namedtuple_fields</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s4">&quot;Cannot overwrite NamedTuple attribute &quot; </span><span class="s2">+ </span><span class="s1">key</span><span class="s2">)</span>
                <span class="s0">elif </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">_special_namedtuple_fields</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">nm_tpl</span><span class="s2">.</span><span class="s1">_fields</span><span class="s2">:</span>
                        <span class="s1">setattr</span><span class="s2">(</span><span class="s1">nm_tpl</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">ns</span><span class="s2">[</span><span class="s1">key</span><span class="s2">])</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s1">set_name </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">val</span><span class="s2">).</span><span class="s1">__set_name__</span>
                    <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
                        <span class="s0">pass</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">try</span><span class="s2">:</span>
                            <span class="s1">set_name</span><span class="s2">(</span><span class="s1">val</span><span class="s2">, </span><span class="s1">nm_tpl</span><span class="s2">, </span><span class="s1">key</span><span class="s2">)</span>
                        <span class="s0">except </span><span class="s1">BaseException </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
                            <span class="s1">msg </span><span class="s2">= (</span>
                                <span class="s4">f&quot;Error calling __set_name__ on </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">val</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">!r} </span><span class="s4">&quot;</span>
                                <span class="s4">f&quot;instance </span><span class="s0">{</span><span class="s1">key</span><span class="s0">!r} </span><span class="s4">in </span><span class="s0">{</span><span class="s1">typename</span><span class="s0">!r}</span><span class="s4">&quot;</span>
                            <span class="s2">)</span>
                            <span class="s3"># BaseException.add_note() existed on py311,</span>
                            <span class="s3"># but the __set_name__ machinery didn't start</span>
                            <span class="s3"># using add_note() until py312.</span>
                            <span class="s3"># Making sure exceptions are raised in the same way</span>
                            <span class="s3"># as in &quot;normal&quot; classes seems most important here.</span>
                            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">):</span>
                                <span class="s1">e</span><span class="s2">.</span><span class="s1">add_note</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
                                <span class="s0">raise</span>
                            <span class="s0">else</span><span class="s2">:</span>
                                <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>

            <span class="s0">if </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic </span><span class="s0">in </span><span class="s1">bases</span><span class="s2">:</span>
                <span class="s1">nm_tpl</span><span class="s2">.</span><span class="s1">__init_subclass__</span><span class="s2">()</span>
            <span class="s0">return </span><span class="s1">nm_tpl</span>

    <span class="s1">_NamedTuple </span><span class="s2">= </span><span class="s1">type</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">_NamedTupleMeta</span><span class="s2">, </span><span class="s4">'NamedTuple'</span><span class="s2">, (), {})</span>

    <span class="s0">def </span><span class="s1">_namedtuple_mro_entries</span><span class="s2">(</span><span class="s1">bases</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">NamedTuple </span><span class="s0">in </span><span class="s1">bases</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">_NamedTuple</span><span class="s2">,)</span>

    <span class="s2">@</span><span class="s1">_ensure_subclassable</span><span class="s2">(</span><span class="s1">_namedtuple_mro_entries</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">NamedTuple</span><span class="s2">(</span><span class="s1">typename</span><span class="s2">, </span><span class="s1">fields</span><span class="s2">=</span><span class="s1">_marker</span><span class="s2">, /, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Typed version of namedtuple. 
 
        Usage:: 
 
            class Employee(NamedTuple): 
                name: str 
                id: int 
 
        This is equivalent to:: 
 
            Employee = collections.namedtuple('Employee', ['name', 'id']) 
 
        The resulting class has an extra __annotations__ attribute, giving a 
        dict that maps field names to types.  (The field names are also in 
        the _fields attribute, which is part of the namedtuple API.) 
        An alternative equivalent functional syntax is also accepted:: 
 
            Employee = NamedTuple('Employee', [('name', str), ('id', int)]) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">fields </span><span class="s0">is </span><span class="s1">_marker</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">kwargs</span><span class="s2">:</span>
                <span class="s1">deprecated_thing </span><span class="s2">= </span><span class="s4">&quot;Creating NamedTuple classes using keyword arguments&quot;</span>
                <span class="s1">deprecation_msg </span><span class="s2">= (</span>
                    <span class="s4">&quot;{name} is deprecated and will be disallowed in Python {remove}. &quot;</span>
                    <span class="s4">&quot;Use the class-based or functional syntax instead.&quot;</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">deprecated_thing </span><span class="s2">= </span><span class="s4">&quot;Failing to pass a value for the 'fields' parameter&quot;</span>
                <span class="s1">example </span><span class="s2">= </span><span class="s4">f&quot;`</span><span class="s0">{</span><span class="s1">typename</span><span class="s0">} </span><span class="s4">= NamedTuple(</span><span class="s0">{</span><span class="s1">typename</span><span class="s0">!r}</span><span class="s4">, [])`&quot;</span>
                <span class="s1">deprecation_msg </span><span class="s2">= (</span>
                    <span class="s4">&quot;{name} is deprecated and will be disallowed in Python {remove}. &quot;</span>
                    <span class="s4">&quot;To create a NamedTuple class with 0 fields &quot;</span>
                    <span class="s4">&quot;using the functional syntax, &quot;</span>
                    <span class="s4">&quot;pass an empty list, e.g. &quot;</span>
                <span class="s2">) + </span><span class="s1">example </span><span class="s2">+ </span><span class="s4">&quot;.&quot;</span>
        <span class="s0">elif </span><span class="s1">fields </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">kwargs</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                    <span class="s4">&quot;Cannot pass `None` as the 'fields' parameter &quot;</span>
                    <span class="s4">&quot;and also specify fields using keyword arguments&quot;</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">deprecated_thing </span><span class="s2">= </span><span class="s4">&quot;Passing `None` as the 'fields' parameter&quot;</span>
                <span class="s1">example </span><span class="s2">= </span><span class="s4">f&quot;`</span><span class="s0">{</span><span class="s1">typename</span><span class="s0">} </span><span class="s4">= NamedTuple(</span><span class="s0">{</span><span class="s1">typename</span><span class="s0">!r}</span><span class="s4">, [])`&quot;</span>
                <span class="s1">deprecation_msg </span><span class="s2">= (</span>
                    <span class="s4">&quot;{name} is deprecated and will be disallowed in Python {remove}. &quot;</span>
                    <span class="s4">&quot;To create a NamedTuple class with 0 fields &quot;</span>
                    <span class="s4">&quot;using the functional syntax, &quot;</span>
                    <span class="s4">&quot;pass an empty list, e.g. &quot;</span>
                <span class="s2">) + </span><span class="s1">example </span><span class="s2">+ </span><span class="s4">&quot;.&quot;</span>
        <span class="s0">elif </span><span class="s1">kwargs</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Either list of fields or keywords&quot;</span>
                            <span class="s4">&quot; can be provided to NamedTuple, not both&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">fields </span><span class="s0">is </span><span class="s1">_marker </span><span class="s0">or </span><span class="s1">fields </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s1">deprecation_msg</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s1">deprecated_thing</span><span class="s2">, </span><span class="s1">remove</span><span class="s2">=</span><span class="s4">&quot;3.15&quot;</span><span class="s2">),</span>
                <span class="s1">DeprecationWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">fields </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
        <span class="s1">nt </span><span class="s2">= </span><span class="s1">_make_nmtuple</span><span class="s2">(</span><span class="s1">typename</span><span class="s2">, </span><span class="s1">fields</span><span class="s2">, </span><span class="s1">module</span><span class="s2">=</span><span class="s1">_caller</span><span class="s2">())</span>
        <span class="s1">nt</span><span class="s2">.</span><span class="s1">__orig_bases__ </span><span class="s2">= (</span><span class="s1">NamedTuple</span><span class="s2">,)</span>
        <span class="s0">return </span><span class="s1">nt</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">, </span><span class="s4">&quot;Buffer&quot;</span><span class="s2">):</span>
    <span class="s1">Buffer </span><span class="s2">= </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Buffer</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">Buffer</span><span class="s2">(</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">ABC</span><span class="s2">):  </span><span class="s3"># noqa: B024</span>
        <span class="s6">&quot;&quot;&quot;Base class for classes that implement the buffer protocol. 
 
        The buffer protocol allows Python objects to expose a low-level 
        memory buffer interface. Before Python 3.12, it is not possible 
        to implement the buffer protocol in pure Python code, or even 
        to check whether a class implements the buffer protocol. In 
        Python 3.12 and higher, the ``__buffer__`` method allows access 
        to the buffer protocol from Python code, and the 
        ``collections.abc.Buffer`` ABC allows checking whether a class 
        implements the buffer protocol. 
 
        To indicate support for the buffer protocol in earlier versions, 
        inherit from this ABC, either in a stub file or at runtime, 
        or use ABC registration. This ABC provides no methods, because 
        there is no Python-accessible methods shared by pre-3.12 buffer 
        classes. It is useful primarily for static checks. 
 
        &quot;&quot;&quot;</span>

    <span class="s3"># As a courtesy, register the most common stdlib buffer classes.</span>
    <span class="s1">Buffer</span><span class="s2">.</span><span class="s1">register</span><span class="s2">(</span><span class="s1">memoryview</span><span class="s2">)</span>
    <span class="s1">Buffer</span><span class="s2">.</span><span class="s1">register</span><span class="s2">(</span><span class="s1">bytearray</span><span class="s2">)</span>
    <span class="s1">Buffer</span><span class="s2">.</span><span class="s1">register</span><span class="s2">(</span><span class="s1">bytes</span><span class="s2">)</span>


<span class="s3"># Backport of types.get_original_bases, available on 3.12+ in CPython</span>
<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">_types</span><span class="s2">, </span><span class="s4">&quot;get_original_bases&quot;</span><span class="s2">):</span>
    <span class="s1">get_original_bases </span><span class="s2">= </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">get_original_bases</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">get_original_bases</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, /):</span>
        <span class="s6">&quot;&quot;&quot;Return the class's &quot;original&quot; bases prior to modification by `__mro_entries__`. 
 
        Examples:: 
 
            from typing import TypeVar, Generic 
            from pip._vendor.typing_extensions import NamedTuple, TypedDict 
 
            T = TypeVar(&quot;T&quot;) 
            class Foo(Generic[T]): ... 
            class Bar(Foo[int], float): ... 
            class Baz(list[str]): ... 
            Eggs = NamedTuple(&quot;Eggs&quot;, [(&quot;a&quot;, int), (&quot;b&quot;, str)]) 
            Spam = TypedDict(&quot;Spam&quot;, {&quot;a&quot;: int, &quot;b&quot;: str}) 
 
            assert get_original_bases(Bar) == (Foo[int], float) 
            assert get_original_bases(Baz) == (list[str],) 
            assert get_original_bases(Eggs) == (NamedTuple,) 
            assert get_original_bases(Spam) == (TypedDict,) 
            assert get_original_bases(int) == (object,) 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;__orig_bases__&quot;</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__bases__</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s4">f'Expected an instance of type, not </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">!r}</span><span class="s4">'</span>
            <span class="s2">) </span><span class="s0">from None</span>


<span class="s3"># NewType is a class on Python 3.10+, making it pickleable</span>
<span class="s3"># The error message for subclassing instances of NewType was improved on 3.11+</span>
<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">11</span><span class="s2">):</span>
    <span class="s1">NewType </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">NewType</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">NewType</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;NewType creates simple unique types with almost zero 
        runtime overhead. NewType(name, tp) is considered a subtype of tp 
        by static type checkers. At runtime, NewType(name, tp) returns 
        a dummy callable that simply returns its argument. Usage:: 
            UserId = NewType('UserId', int) 
            def name_by_id(user_id: UserId) -&gt; str: 
                ... 
            UserId('user')          # Fails type check 
            name_by_id(42)          # Fails type check 
            name_by_id(UserId(42))  # OK 
            num = UserId(5) + 1     # type: int 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, /):</span>
            <span class="s0">return </span><span class="s1">obj</span>

        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__qualname__ </span><span class="s2">= </span><span class="s1">name</span>
            <span class="s0">if </span><span class="s4">'.' </span><span class="s0">in </span><span class="s1">name</span><span class="s2">:</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s1">name</span><span class="s2">.</span><span class="s1">rpartition</span><span class="s2">(</span><span class="s4">'.'</span><span class="s2">)[-</span><span class="s5">1</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s1">name</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__supertype__ </span><span class="s2">= </span><span class="s1">tp</span>
            <span class="s1">def_mod </span><span class="s2">= </span><span class="s1">_caller</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">def_mod </span><span class="s2">!= </span><span class="s4">'typing_extensions'</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__module__ </span><span class="s2">= </span><span class="s1">def_mod</span>

        <span class="s0">def </span><span class="s1">__mro_entries__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">bases</span><span class="s2">):</span>
            <span class="s3"># We defined __mro_entries__ to get a better error message</span>
            <span class="s3"># if a user attempts to subclass a NewType instance. bpo-46170</span>
            <span class="s1">supercls_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__name__</span>

            <span class="s0">class </span><span class="s1">Dummy</span><span class="s2">:</span>
                <span class="s0">def </span><span class="s1">__init_subclass__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">):</span>
                    <span class="s1">subcls_name </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__name__</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                        <span class="s4">f&quot;Cannot subclass an instance of NewType. &quot;</span>
                        <span class="s4">f&quot;Perhaps you were looking for: &quot;</span>
                        <span class="s4">f&quot;`</span><span class="s0">{</span><span class="s1">subcls_name</span><span class="s0">} </span><span class="s4">= NewType(</span><span class="s0">{</span><span class="s1">subcls_name</span><span class="s0">!r}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">supercls_name</span><span class="s0">}</span><span class="s4">)`&quot;</span>
                    <span class="s2">)</span>

            <span class="s0">return </span><span class="s2">(</span><span class="s1">Dummy</span><span class="s2">,)</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__module__</span><span class="s0">}</span><span class="s4">.</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__qualname__</span><span class="s0">}</span><span class="s4">'</span>

        <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__qualname__</span>

        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">):</span>
            <span class="s3"># PEP 604 methods</span>
            <span class="s3"># It doesn't make sense to have these methods on Python &lt;3.10</span>

            <span class="s0">def </span><span class="s1">__or__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">]</span>

            <span class="s0">def </span><span class="s1">__ror__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">other</span><span class="s2">, </span><span class="s1">self</span><span class="s2">]</span>


<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">14</span><span class="s2">):</span>
    <span class="s1">TypeAliasType </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeAliasType</span>
<span class="s3"># 3.8-3.13</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">):</span>
        <span class="s3"># 3.12-3.14</span>
        <span class="s0">def </span><span class="s1">_is_unionable</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">):</span>
            <span class="s6">&quot;&quot;&quot;Corresponds to is_unionable() in unionobject.c in CPython.&quot;&quot;&quot;</span>
            <span class="s0">return </span><span class="s1">obj </span><span class="s0">is None or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, (</span>
                <span class="s1">type</span><span class="s2">,</span>
                <span class="s1">_types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">,</span>
                <span class="s1">_types</span><span class="s2">.</span><span class="s1">UnionType</span><span class="s2">,</span>
                <span class="s1">typing</span><span class="s2">.</span><span class="s1">TypeAliasType</span><span class="s2">,</span>
                <span class="s1">TypeAliasType</span><span class="s2">,</span>
            <span class="s2">))</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s3"># 3.8-3.11</span>
        <span class="s0">def </span><span class="s1">_is_unionable</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">):</span>
            <span class="s6">&quot;&quot;&quot;Corresponds to is_unionable() in unionobject.c in CPython.&quot;&quot;&quot;</span>
            <span class="s0">return </span><span class="s1">obj </span><span class="s0">is None or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, (</span>
                <span class="s1">type</span><span class="s2">,</span>
                <span class="s1">_types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">,</span>
                <span class="s1">_types</span><span class="s2">.</span><span class="s1">UnionType</span><span class="s2">,</span>
                <span class="s1">TypeAliasType</span><span class="s2">,</span>
            <span class="s2">))</span>

    <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">):</span>
        <span class="s3"># Copied and pasted from https://github.com/python/cpython/blob/986a4e1b6fcae7fe7a1d0a26aea446107dd58dd2/Objects/genericaliasobject.c#L568-L582,</span>
        <span class="s3"># so that we emulate the behaviour of `types.GenericAlias`</span>
        <span class="s3"># on the latest versions of CPython</span>
        <span class="s1">_ATTRIBUTE_DELEGATION_EXCLUSIONS </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">({</span>
            <span class="s4">&quot;__class__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__bases__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__origin__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__args__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__unpacked__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__parameters__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__typing_unpacked_tuple_args__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__mro_entries__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__reduce_ex__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__reduce__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__copy__&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;__deepcopy__&quot;</span><span class="s2">,</span>
        <span class="s2">})</span>

        <span class="s0">class </span><span class="s1">_TypeAliasGenericAlias</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">, </span><span class="s1">_root</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
            <span class="s0">def </span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">_ATTRIBUTE_DELEGATION_EXCLUSIONS</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__origin__</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
                <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">):</span>
                    <span class="s1">result </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">item</span><span class="s2">)</span>
                    <span class="s1">result</span><span class="s2">.</span><span class="s1">__class__ </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">class </span><span class="s1">TypeAliasType</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Create named, parameterized type aliases. 
 
        This provides a backport of the new `type` statement in Python 3.12: 
 
            type ListOrSet[T] = list[T] | set[T] 
 
        is equivalent to: 
 
            T = TypeVar(&quot;T&quot;) 
            ListOrSet = TypeAliasType(&quot;ListOrSet&quot;, list[T] | set[T], type_params=(T,)) 
 
        The name ListOrSet can then be used as an alias for the type it refers to. 
 
        The type_params argument should contain all the type parameters used 
        in the value of the type alias. If the alias is not generic, this 
        argument is omitted. 
 
        Static type checkers should only support type aliases declared using 
        TypeAliasType that follow these rules: 
 
        - The first argument (the name) must be a string literal. 
        - The TypeAliasType instance must be immediately assigned to a variable 
          of the same name. (For example, 'X = TypeAliasType(&quot;Y&quot;, int)' is invalid, 
          as is 'X, Y = TypeAliasType(&quot;X&quot;, int), TypeAliasType(&quot;Y&quot;, int)'). 
 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, *, </span><span class="s1">type_params</span><span class="s2">=()):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;TypeAliasType name must be a string&quot;</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">type_params</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;type_params must be a tuple&quot;</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__value__ </span><span class="s2">= </span><span class="s1">value</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__type_params__ </span><span class="s2">= </span><span class="s1">type_params</span>

            <span class="s1">default_value_encountered </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">parameters </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">type_param </span><span class="s0">in </span><span class="s1">type_params</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s0">not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">type_param</span><span class="s2">, (</span><span class="s1">TypeVar</span><span class="s2">, </span><span class="s1">TypeVarTuple</span><span class="s2">, </span><span class="s1">ParamSpec</span><span class="s2">))</span>
                    <span class="s3"># 3.8-3.11</span>
                    <span class="s3"># Unpack Backport passes isinstance(type_param, TypeVar)</span>
                    <span class="s0">or </span><span class="s1">_is_unpack</span><span class="s2">(</span><span class="s1">type_param</span><span class="s2">)</span>
                <span class="s2">):</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Expected a type param, got </span><span class="s0">{</span><span class="s1">type_param</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s2">)</span>
                <span class="s1">has_default </span><span class="s2">= (</span>
                    <span class="s1">getattr</span><span class="s2">(</span><span class="s1">type_param</span><span class="s2">, </span><span class="s4">'__default__'</span><span class="s2">, </span><span class="s1">NoDefault</span><span class="s2">) </span><span class="s0">is not </span><span class="s1">NoDefault</span>
                <span class="s2">)</span>
                <span class="s0">if </span><span class="s1">default_value_encountered </span><span class="s0">and not </span><span class="s1">has_default</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;non-default type parameter '</span><span class="s0">{</span><span class="s1">type_param</span><span class="s0">!r}</span><span class="s4">'&quot;</span>
                                    <span class="s4">&quot; follows default type parameter&quot;</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">has_default</span><span class="s2">:</span>
                    <span class="s1">default_value_encountered </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">type_param</span><span class="s2">, </span><span class="s1">TypeVarTuple</span><span class="s2">):</span>
                    <span class="s1">parameters</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">type_param</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">parameters</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">type_param</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__parameters__ </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">)</span>
            <span class="s1">def_mod </span><span class="s2">= </span><span class="s1">_caller</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">def_mod </span><span class="s2">!= </span><span class="s4">'typing_extensions'</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__module__ </span><span class="s2">= </span><span class="s1">def_mod</span>
            <span class="s3"># Setting this attribute closes the TypeAliasType from further modification</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s1">name</span>

        <span class="s0">def </span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">object</span><span class="s2">, /) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;__name__&quot;</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_raise_attribute_error</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__delattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, /) </span><span class="s1">-&gt; Never</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_raise_attribute_error</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">_raise_attribute_error</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Never</span><span class="s2">:</span>
            <span class="s3"># Match the Python 3.12 error messages exactly</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s4">&quot;__name__&quot;</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s4">&quot;readonly attribute&quot;</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">name </span><span class="s0">in </span><span class="s2">{</span><span class="s4">&quot;__value__&quot;</span><span class="s2">, </span><span class="s4">&quot;__type_params__&quot;</span><span class="s2">, </span><span class="s4">&quot;__parameters__&quot;</span><span class="s2">, </span><span class="s4">&quot;__module__&quot;</span><span class="s2">}:</span>
                <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span>
                    <span class="s4">f&quot;attribute '</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">' of 'typing.TypeAliasType' objects &quot;</span>
                    <span class="s4">&quot;is not writable&quot;</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span>
                    <span class="s4">f&quot;'typing.TypeAliasType' object has no attribute '</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">'&quot;</span>
                <span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__name__</span>

        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">11</span><span class="s2">):</span>
            <span class="s0">def </span><span class="s1">_check_single_param</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">param</span><span class="s2">, </span><span class="s1">recursion</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
                <span class="s3"># Allow [], [int], [int, str], [int, ...], [int, T]</span>
                <span class="s0">if </span><span class="s1">param </span><span class="s0">is </span><span class="s2">...:</span>
                    <span class="s0">return </span><span class="s2">...</span>
                <span class="s0">if </span><span class="s1">param </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s0">return None</span>
                <span class="s3"># Note in &lt;= 3.9 _ConcatenateGenericAlias inherits from list</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">param</span><span class="s2">, </span><span class="s1">list</span><span class="s2">) </span><span class="s0">and </span><span class="s1">recursion </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_single_param</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">recursion</span><span class="s2">+</span><span class="s5">1</span><span class="s2">)</span>
                            <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">param</span><span class="s2">]</span>
                <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span>
                        <span class="s1">param</span><span class="s2">, </span><span class="s4">f'Subscripting </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">} </span><span class="s4">requires a type.'</span>
                    <span class="s2">)</span>

        <span class="s0">def </span><span class="s1">_check_parameters</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">11</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_single_param</span><span class="s2">(</span><span class="s1">item</span><span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">parameters</span>
                <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_check</span><span class="s2">(</span>
                        <span class="s1">item</span><span class="s2">, </span><span class="s4">f'Subscripting </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">} </span><span class="s4">requires a type.'</span>
                    <span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">parameters</span>
            <span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__type_params__</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Only generic type aliases are subscriptable&quot;</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s1">parameters </span><span class="s2">= (</span><span class="s1">parameters</span><span class="s2">,)</span>
            <span class="s3"># Using 3.9 here will create problems with Concatenate</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">GenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">)</span>
            <span class="s1">type_vars </span><span class="s2">= </span><span class="s1">_collect_type_vars</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">)</span>
            <span class="s1">parameters </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_check_parameters</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">)</span>
            <span class="s1">alias </span><span class="s2">= </span><span class="s1">_TypeAliasGenericAlias</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">)</span>
            <span class="s3"># alias.__parameters__ is not complete if Concatenate is present</span>
            <span class="s3"># as it is converted to a list from which no parameters are extracted.</span>
            <span class="s0">if </span><span class="s1">alias</span><span class="s2">.</span><span class="s1">__parameters__ </span><span class="s2">!= </span><span class="s1">type_vars</span><span class="s2">:</span>
                <span class="s1">alias</span><span class="s2">.</span><span class="s1">__parameters__ </span><span class="s2">= </span><span class="s1">type_vars</span>
            <span class="s0">return </span><span class="s1">alias</span>

        <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__name__</span>

        <span class="s0">def </span><span class="s1">__init_subclass__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s4">&quot;type 'typing_extensions.TypeAliasType' is not an acceptable base type&quot;</span>
            <span class="s2">)</span>

        <span class="s3"># The presence of this method convinces typing._type_check</span>
        <span class="s3"># that TypeAliasTypes are types.</span>
        <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;Type alias is not callable&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">):</span>
            <span class="s0">def </span><span class="s1">__or__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">right</span><span class="s2">):</span>
                <span class="s3"># For forward compatibility with 3.12, reject Unions</span>
                <span class="s3"># that are not accepted by the built-in Union.</span>
                <span class="s0">if not </span><span class="s1">_is_unionable</span><span class="s2">(</span><span class="s1">right</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">NotImplemented</span>
                <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">self</span><span class="s2">, </span><span class="s1">right</span><span class="s2">]</span>

            <span class="s0">def </span><span class="s1">__ror__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">left</span><span class="s2">):</span>
                <span class="s0">if not </span><span class="s1">_is_unionable</span><span class="s2">(</span><span class="s1">left</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">NotImplemented</span>
                <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">left</span><span class="s2">, </span><span class="s1">self</span><span class="s2">]</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;is_protocol&quot;</span><span class="s2">):</span>
    <span class="s1">is_protocol </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">is_protocol</span>
    <span class="s1">get_protocol_members </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">get_protocol_members</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">is_protocol</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">: </span><span class="s1">type</span><span class="s2">, /) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Return True if the given type is a Protocol. 
 
        Example:: 
 
            &gt;&gt;&gt; from typing_extensions import Protocol, is_protocol 
            &gt;&gt;&gt; class P(Protocol): 
            ...     def a(self) -&gt; str: ... 
            ...     b: int 
            &gt;&gt;&gt; is_protocol(P) 
            True 
            &gt;&gt;&gt; is_protocol(int) 
            False 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">type</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s4">'_is_protocol'</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">tp </span><span class="s0">is not </span><span class="s1">Protocol</span>
            <span class="s0">and </span><span class="s1">tp </span><span class="s0">is not </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Protocol</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_protocol_members</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">: </span><span class="s1">type</span><span class="s2">, /) </span><span class="s1">-&gt; typing</span><span class="s2">.</span><span class="s1">FrozenSet</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s6">&quot;&quot;&quot;Return the set of members defined in a Protocol. 
 
        Example:: 
 
            &gt;&gt;&gt; from typing_extensions import Protocol, get_protocol_members 
            &gt;&gt;&gt; class P(Protocol): 
            ...     def a(self) -&gt; str: ... 
            ...     b: int 
            &gt;&gt;&gt; get_protocol_members(P) 
            frozenset({'a', 'b'}) 
 
        Raise a TypeError for arguments that are not Protocols. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">is_protocol</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f'</span><span class="s0">{</span><span class="s1">tp</span><span class="s0">!r} </span><span class="s4">is not a Protocol'</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s4">'__protocol_attrs__'</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">.</span><span class="s1">__protocol_attrs__</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">_get_protocol_attrs</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">))</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;Doc&quot;</span><span class="s2">):</span>
    <span class="s1">Doc </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Doc</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">class </span><span class="s1">Doc</span><span class="s2">:</span>
        <span class="s6">&quot;&quot;&quot;Define the documentation of a type annotation using ``Annotated``, to be 
         used in class attributes, function and method parameters, return values, 
         and variables. 
 
        The value should be a positional-only string literal to allow static tools 
        like editors and documentation generators to use it. 
 
        This complements docstrings. 
 
        The string value passed is available in the attribute ``documentation``. 
 
        Example:: 
 
            &gt;&gt;&gt; from typing_extensions import Annotated, Doc 
            &gt;&gt;&gt; def hi(to: Annotated[str, Doc(&quot;Who to say hi to&quot;)]) -&gt; None: ... 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">documentation</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, /) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">documentation </span><span class="s2">= </span><span class="s1">documentation</span>

        <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s4">f&quot;Doc(</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">documentation</span><span class="s0">!r}</span><span class="s4">)&quot;</span>

        <span class="s0">def </span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">hash</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">documentation</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">: </span><span class="s1">object</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">Doc</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">documentation </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">documentation</span>


<span class="s1">_CapsuleType </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_types</span><span class="s2">, </span><span class="s4">&quot;CapsuleType&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

<span class="s0">if </span><span class="s1">_CapsuleType </span><span class="s0">is None</span><span class="s2">:</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">import </span><span class="s1">_socket</span>
    <span class="s0">except </span><span class="s1">ImportError</span><span class="s2">:</span>
        <span class="s0">pass</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">_CAPI </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_socket</span><span class="s2">, </span><span class="s4">&quot;CAPI&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">_CAPI </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">_CapsuleType </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">_CAPI</span><span class="s2">)</span>

<span class="s0">if </span><span class="s1">_CapsuleType </span><span class="s0">is not None</span><span class="s2">:</span>
    <span class="s1">CapsuleType </span><span class="s2">= </span><span class="s1">_CapsuleType</span>
    <span class="s1">__all__</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s4">&quot;CapsuleType&quot;</span><span class="s2">)</span>


<span class="s3"># Using this convoluted approach so that this keeps working</span>
<span class="s3"># whether we end up using PEP 649 as written, PEP 749, or</span>
<span class="s3"># some other variation: in any case, inspect.get_annotations</span>
<span class="s3"># will continue to exist and will gain a `format` parameter.</span>
<span class="s1">_PEP_649_OR_749_IMPLEMENTED </span><span class="s2">= (</span>
    <span class="s1">hasattr</span><span class="s2">(</span><span class="s1">inspect</span><span class="s2">, </span><span class="s4">'get_annotations'</span><span class="s2">)</span>
    <span class="s0">and </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">get_annotations</span><span class="s2">.</span><span class="s1">__kwdefaults__ </span><span class="s0">is not None</span>
    <span class="s0">and </span><span class="s4">&quot;format&quot; </span><span class="s0">in </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">get_annotations</span><span class="s2">.</span><span class="s1">__kwdefaults__</span>
<span class="s2">)</span>


<span class="s0">class </span><span class="s1">Format</span><span class="s2">(</span><span class="s1">enum</span><span class="s2">.</span><span class="s1">IntEnum</span><span class="s2">):</span>
    <span class="s1">VALUE </span><span class="s2">= </span><span class="s5">1</span>
    <span class="s1">FORWARDREF </span><span class="s2">= </span><span class="s5">2</span>
    <span class="s1">STRING </span><span class="s2">= </span><span class="s5">3</span>


<span class="s0">if </span><span class="s1">_PEP_649_OR_749_IMPLEMENTED</span><span class="s2">:</span>
    <span class="s1">get_annotations </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">get_annotations</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">get_annotations</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, *, </span><span class="s1">globals</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">locals</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">eval_str</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                        <span class="s1">format</span><span class="s2">=</span><span class="s1">Format</span><span class="s2">.</span><span class="s1">VALUE</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Compute the annotations dict for an object. 
 
        obj may be a callable, class, or module. 
        Passing in an object of any other type raises TypeError. 
 
        Returns a dict.  get_annotations() returns a new dict every time 
        it's called; calling it twice on the same object will return two 
        different but equivalent dicts. 
 
        This is a backport of `inspect.get_annotations`, which has been 
        in the standard library since Python 3.10. See the standard library 
        documentation for more: 
 
            https://docs.python.org/3/library/inspect.html#inspect.get_annotations 
 
        This backport adds the *format* argument introduced by PEP 649. The 
        three formats supported are: 
        * VALUE: the annotations are returned as-is. This is the default and 
          it is compatible with the behavior on previous Python versions. 
        * FORWARDREF: return annotations as-is if possible, but replace any 
          undefined names with ForwardRef objects. The implementation proposed by 
          PEP 649 relies on language changes that cannot be backported; the 
          typing-extensions implementation simply returns the same result as VALUE. 
        * STRING: return annotations as strings, in a format close to the original 
          source. Again, this behavior cannot be replicated directly in a backport. 
          As an approximation, typing-extensions retrieves the annotations under 
          VALUE semantics and then stringifies them. 
 
        The purpose of this backport is to allow users who would like to use 
        FORWARDREF or STRING semantics once PEP 649 is implemented, but who also 
        want to support earlier Python versions, to simply write: 
 
            typing_extensions.get_annotations(obj, format=Format.FORWARDREF) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">format </span><span class="s2">= </span><span class="s1">Format</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">eval_str </span><span class="s0">and </span><span class="s1">format </span><span class="s0">is not </span><span class="s1">Format</span><span class="s2">.</span><span class="s1">VALUE</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;eval_str=True is only supported with format=Format.VALUE&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
            <span class="s3"># class</span>
            <span class="s1">obj_dict </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">'__dict__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">obj_dict </span><span class="s0">and </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">obj_dict</span><span class="s2">, </span><span class="s4">'get'</span><span class="s2">):</span>
                <span class="s1">ann </span><span class="s2">= </span><span class="s1">obj_dict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'__annotations__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ann</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">GetSetDescriptorType</span><span class="s2">):</span>
                    <span class="s1">ann </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">ann </span><span class="s2">= </span><span class="s0">None</span>

            <span class="s1">obj_globals </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s1">module_name </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">'__module__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">module_name</span><span class="s2">:</span>
                <span class="s1">module </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">modules</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">module_name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">module</span><span class="s2">:</span>
                    <span class="s1">obj_globals </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s4">'__dict__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">obj_locals </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">vars</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">))</span>
            <span class="s1">unwrap </span><span class="s2">= </span><span class="s1">obj</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">ModuleType</span><span class="s2">):</span>
            <span class="s3"># module</span>
            <span class="s1">ann </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">'__annotations__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">obj_globals </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">__dict__</span>
            <span class="s1">obj_locals </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s1">unwrap </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">elif </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">):</span>
            <span class="s3"># this includes types.Function, types.BuiltinFunctionType,</span>
            <span class="s3"># types.BuiltinMethodType, functools.partial, functools.singledispatch,</span>
            <span class="s3"># &quot;class funclike&quot; from Lib/test/test_inspect... on and on it goes.</span>
            <span class="s1">ann </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">'__annotations__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">obj_globals </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">'__globals__'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">obj_locals </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s1">unwrap </span><span class="s2">= </span><span class="s1">obj</span>
        <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">'__annotations__'</span><span class="s2">):</span>
            <span class="s1">ann </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">__annotations__</span>
            <span class="s1">obj_globals </span><span class="s2">= </span><span class="s1">obj_locals </span><span class="s2">= </span><span class="s1">unwrap </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">!r} </span><span class="s4">is not a module, class, or callable.&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">ann </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">{}</span>

        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ann</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj</span><span class="s0">!r}</span><span class="s4">.__annotations__ is neither a dict nor None&quot;</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">ann</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">{}</span>

        <span class="s0">if not </span><span class="s1">eval_str</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">format </span><span class="s0">is </span><span class="s1">Format</span><span class="s2">.</span><span class="s1">STRING</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s2">{</span>
                    <span class="s1">key</span><span class="s2">: </span><span class="s1">value </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">str</span><span class="s2">) </span><span class="s0">else </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_repr</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">ann</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                <span class="s2">}</span>
            <span class="s0">return </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">ann</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">unwrap </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">while True</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">unwrap</span><span class="s2">, </span><span class="s4">'__wrapped__'</span><span class="s2">):</span>
                    <span class="s1">unwrap </span><span class="s2">= </span><span class="s1">unwrap</span><span class="s2">.</span><span class="s1">__wrapped__</span>
                    <span class="s0">continue</span>
                <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">unwrap</span><span class="s2">, </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">):</span>
                    <span class="s1">unwrap </span><span class="s2">= </span><span class="s1">unwrap</span><span class="s2">.</span><span class="s1">func</span>
                    <span class="s0">continue</span>
                <span class="s0">break</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">unwrap</span><span class="s2">, </span><span class="s4">&quot;__globals__&quot;</span><span class="s2">):</span>
                <span class="s1">obj_globals </span><span class="s2">= </span><span class="s1">unwrap</span><span class="s2">.</span><span class="s1">__globals__</span>

        <span class="s0">if </span><span class="s1">globals </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">globals </span><span class="s2">= </span><span class="s1">obj_globals</span>
        <span class="s0">if </span><span class="s1">locals </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">locals </span><span class="s2">= </span><span class="s1">obj_locals </span><span class="s0">or </span><span class="s2">{}</span>

        <span class="s3"># &quot;Inject&quot; type parameters into the local namespace</span>
        <span class="s3"># (unless they are shadowed by assignments *in* the local namespace),</span>
        <span class="s3"># as a way of emulating annotation scopes when calling `eval()`</span>
        <span class="s0">if </span><span class="s1">type_params </span><span class="s2">:= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s4">&quot;__type_params__&quot;</span><span class="s2">, ()):</span>
            <span class="s1">locals </span><span class="s2">= {</span><span class="s1">param</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">: </span><span class="s1">param </span><span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">type_params</span><span class="s2">} | </span><span class="s1">locals</span>

        <span class="s1">return_value </span><span class="s2">= {</span><span class="s1">key</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">str</span><span class="s2">) </span><span class="s0">else </span><span class="s1">eval</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s1">locals</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">ann</span><span class="s2">.</span><span class="s1">items</span><span class="s2">() }</span>
        <span class="s0">return </span><span class="s1">return_value</span>


<span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;evaluate_forward_ref&quot;</span><span class="s2">):</span>
    <span class="s1">evaluate_forward_ref </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">evaluate_forward_ref</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s3"># Implements annotationlib.ForwardRef.evaluate</span>
    <span class="s0">def </span><span class="s1">_eval_with_owner</span><span class="s2">(</span>
        <span class="s1">forward_ref</span><span class="s2">, *, </span><span class="s1">owner</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">locals</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">type_params</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">):</span>
        <span class="s0">if </span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_evaluated__</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_value__</span>
        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">forward_ref</span><span class="s2">, </span><span class="s4">&quot;__cell__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__cell__</span><span class="s2">.</span><span class="s1">cell_contents</span>
            <span class="s0">except </span><span class="s1">ValueError</span><span class="s2">:</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_evaluated__ </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_value__ </span><span class="s2">= </span><span class="s1">value</span>
                <span class="s0">return </span><span class="s1">value</span>
        <span class="s0">if </span><span class="s1">owner </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">owner </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">forward_ref</span><span class="s2">, </span><span class="s4">&quot;__owner__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">globals </span><span class="s0">is None</span>
            <span class="s0">and </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">forward_ref</span><span class="s2">, </span><span class="s4">&quot;__forward_module__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) </span><span class="s0">is not None</span>
        <span class="s2">):</span>
            <span class="s1">globals </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span>
                <span class="s1">sys</span><span class="s2">.</span><span class="s1">modules</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_module__</span><span class="s2">, </span><span class="s0">None</span><span class="s2">), </span><span class="s4">&quot;__dict__&quot;</span><span class="s2">, </span><span class="s0">None</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">globals </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">globals </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">forward_ref</span><span class="s2">, </span><span class="s4">&quot;__globals__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">globals </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
                <span class="s1">module_name </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">, </span><span class="s4">&quot;__module__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">module_name</span><span class="s2">:</span>
                    <span class="s1">module </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">modules</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">module_name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">module</span><span class="s2">:</span>
                        <span class="s1">globals </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s4">&quot;__dict__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">, </span><span class="s1">_types</span><span class="s2">.</span><span class="s1">ModuleType</span><span class="s2">):</span>
                <span class="s1">globals </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">, </span><span class="s4">&quot;__dict__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">):</span>
                <span class="s1">globals </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">, </span><span class="s4">&quot;__globals__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

        <span class="s3"># If we pass None to eval() below, the globals of this module are used.</span>
        <span class="s0">if </span><span class="s1">globals </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">globals </span><span class="s2">= {}</span>

        <span class="s0">if </span><span class="s1">locals </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">locals </span><span class="s2">= {}</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
                <span class="s1">locals</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">vars</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">type_params </span><span class="s0">is None and </span><span class="s1">owner </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s3"># &quot;Inject&quot; type parameters into the local namespace</span>
            <span class="s3"># (unless they are shadowed by assignments *in* the local namespace),</span>
            <span class="s3"># as a way of emulating annotation scopes when calling `eval()`</span>
            <span class="s1">type_params </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">, </span><span class="s4">&quot;__type_params__&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

        <span class="s3"># type parameters require some special handling,</span>
        <span class="s3"># as they exist in their own scope</span>
        <span class="s3"># but `eval()` does not have a dedicated parameter for that scope.</span>
        <span class="s3"># For classes, names in type parameter scopes should override</span>
        <span class="s3"># names in the global scope (which here are called `localns`!),</span>
        <span class="s3"># but should in turn be overridden by names in the class scope</span>
        <span class="s3"># (which here are called `globalns`!)</span>
        <span class="s0">if </span><span class="s1">type_params </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">globals </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">globals</span><span class="s2">)</span>
            <span class="s1">locals </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">locals</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">type_params</span><span class="s2">:</span>
                <span class="s1">param_name </span><span class="s2">= </span><span class="s1">param</span><span class="s2">.</span><span class="s1">__name__</span>
                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s1">_FORWARD_REF_HAS_CLASS </span><span class="s0">and not </span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_is_class__</span>
                <span class="s2">) </span><span class="s0">or </span><span class="s1">param_name </span><span class="s0">not in </span><span class="s1">globals</span><span class="s2">:</span>
                    <span class="s1">globals</span><span class="s2">[</span><span class="s1">param_name</span><span class="s2">] = </span><span class="s1">param</span>
                    <span class="s1">locals</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">param_name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

        <span class="s1">arg </span><span class="s2">= </span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_arg__</span>
        <span class="s0">if </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">isidentifier</span><span class="s2">() </span><span class="s0">and not </span><span class="s1">keyword</span><span class="s2">.</span><span class="s1">iskeyword</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">locals</span><span class="s2">:</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">locals</span><span class="s2">[</span><span class="s1">arg</span><span class="s2">]</span>
            <span class="s0">elif </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">globals</span><span class="s2">:</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">globals</span><span class="s2">[</span><span class="s1">arg</span><span class="s2">]</span>
            <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">builtins</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">builtins</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">NameError</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">code </span><span class="s2">= </span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_code__</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">eval</span><span class="s2">(</span><span class="s1">code</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s1">locals</span><span class="s2">)</span>
        <span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_evaluated__ </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_value__ </span><span class="s2">= </span><span class="s1">value</span>
        <span class="s0">return </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">_lax_type_check</span><span class="s2">(</span>
        <span class="s1">value</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">is_argument</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, *, </span><span class="s1">module</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">allow_special_forms</span><span class="s2">=</span><span class="s0">False</span>
    <span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        A lax Python 3.11+ like version of typing._type_check 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">typing</span><span class="s2">, </span><span class="s4">&quot;_type_convert&quot;</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s2">(</span>
                <span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">3</span><span class="s2">)</span>
                <span class="s0">or </span><span class="s2">(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s2">) &lt; </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">[:</span><span class="s5">3</span><span class="s2">] &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">10</span><span class="s2">)</span>
            <span class="s2">):</span>
                <span class="s3"># allow_special_forms introduced later cpython/#30926 (bpo-46539)</span>
                <span class="s1">type_ </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_convert</span><span class="s2">(</span>
                    <span class="s1">value</span><span class="s2">,</span>
                    <span class="s1">module</span><span class="s2">=</span><span class="s1">module</span><span class="s2">,</span>
                    <span class="s1">allow_special_forms</span><span class="s2">=</span><span class="s1">allow_special_forms</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s3"># module was added with bpo-41249 before is_class (bpo-46539)</span>
            <span class="s0">elif </span><span class="s4">&quot;__forward_module__&quot; </span><span class="s0">in </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ForwardRef</span><span class="s2">.</span><span class="s1">__slots__</span><span class="s2">:</span>
                <span class="s1">type_ </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_convert</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">module</span><span class="s2">=</span><span class="s1">module</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">type_ </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_type_convert</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">ForwardRef</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
            <span class="s1">type_ </span><span class="s2">= </span><span class="s1">value</span>
        <span class="s1">invalid_generic_forms </span><span class="s2">= (</span><span class="s1">Generic</span><span class="s2">, </span><span class="s1">Protocol</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">allow_special_forms</span><span class="s2">:</span>
            <span class="s1">invalid_generic_forms </span><span class="s2">+= (</span><span class="s1">ClassVar</span><span class="s2">,)</span>
            <span class="s0">if </span><span class="s1">is_argument</span><span class="s2">:</span>
                <span class="s1">invalid_generic_forms </span><span class="s2">+= (</span><span class="s1">Final</span><span class="s2">,)</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_GenericAlias</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">get_origin</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">) </span><span class="s0">in </span><span class="s1">invalid_generic_forms</span>
        <span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">type_</span><span class="s0">} </span><span class="s4">is not valid as type argument&quot;</span><span class="s2">) </span><span class="s0">from None</span>
        <span class="s0">if </span><span class="s1">type_ </span><span class="s0">in </span><span class="s2">(</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">LiteralString</span><span class="s2">, </span><span class="s1">NoReturn</span><span class="s2">, </span><span class="s1">Never</span><span class="s2">, </span><span class="s1">Self</span><span class="s2">, </span><span class="s1">TypeAlias</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">type_</span>
        <span class="s0">if </span><span class="s1">allow_special_forms </span><span class="s0">and </span><span class="s1">type_ </span><span class="s0">in </span><span class="s2">(</span><span class="s1">ClassVar</span><span class="s2">, </span><span class="s1">Final</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">type_</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, (</span><span class="s1">_SpecialForm</span><span class="s2">, </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_SpecialForm</span><span class="s2">))</span>
            <span class="s0">or </span><span class="s1">type_ </span><span class="s0">in </span><span class="s2">(</span><span class="s1">Generic</span><span class="s2">, </span><span class="s1">Protocol</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;Plain </span><span class="s0">{</span><span class="s1">type_</span><span class="s0">} </span><span class="s4">is not valid as type argument&quot;</span><span class="s2">) </span><span class="s0">from None</span>
        <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">) </span><span class="s0">is </span><span class="s1">tuple</span><span class="s2">:  </span><span class="s3"># lax version with tuple instead of callable</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">msg</span><span class="s0">} </span><span class="s4">Got </span><span class="s0">{</span><span class="s1">type_</span><span class="s0">!r:</span><span class="s4">.100</span><span class="s0">}</span><span class="s4">.&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">type_</span>

    <span class="s0">def </span><span class="s1">evaluate_forward_ref</span><span class="s2">(</span>
        <span class="s1">forward_ref</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">owner</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">globals</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">locals</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">type_params</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">format</span><span class="s2">=</span><span class="s1">Format</span><span class="s2">.</span><span class="s1">VALUE</span><span class="s2">,</span>
        <span class="s1">_recursive_guard</span><span class="s2">=</span><span class="s1">frozenset</span><span class="s2">(),</span>
    <span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Evaluate a forward reference as a type hint. 
 
        This is similar to calling the ForwardRef.evaluate() method, 
        but unlike that method, evaluate_forward_ref() also: 
 
        * Recursively evaluates forward references nested within the type hint. 
        * Rejects certain objects that are not valid type hints. 
        * Replaces type hints that evaluate to None with types.NoneType. 
        * Supports the *FORWARDREF* and *STRING* formats. 
 
        *forward_ref* must be an instance of ForwardRef. *owner*, if given, 
        should be the object that holds the annotations that the forward reference 
        derived from, such as a module, class object, or function. It is used to 
        infer the namespaces to use for looking up names. *globals* and *locals* 
        can also be explicitly given to provide the global and local namespaces. 
        *type_params* is a tuple of type parameters that are in scope when 
        evaluating the forward reference. This parameter must be provided (though 
        it may be an empty tuple) if *owner* is not given and the forward reference 
        does not already have an owner set. *format* specifies the format of the 
        annotation and is a member of the annotationlib.Format enum. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">format </span><span class="s2">== </span><span class="s1">Format</span><span class="s2">.</span><span class="s1">STRING</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_arg__</span>
        <span class="s0">if </span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_arg__ </span><span class="s0">in </span><span class="s1">_recursive_guard</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">forward_ref</span>

        <span class="s3"># Evaluate the forward reference</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">_eval_with_owner</span><span class="s2">(</span>
                <span class="s1">forward_ref</span><span class="s2">,</span>
                <span class="s1">owner</span><span class="s2">=</span><span class="s1">owner</span><span class="s2">,</span>
                <span class="s1">globals</span><span class="s2">=</span><span class="s1">globals</span><span class="s2">,</span>
                <span class="s1">locals</span><span class="s2">=</span><span class="s1">locals</span><span class="s2">,</span>
                <span class="s1">type_params</span><span class="s2">=</span><span class="s1">type_params</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">except </span><span class="s1">NameError</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">format </span><span class="s2">== </span><span class="s1">Format</span><span class="s2">.</span><span class="s1">FORWARDREF</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">forward_ref</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise</span>

        <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;Forward references must evaluate to types.&quot;</span>
        <span class="s0">if not </span><span class="s1">_FORWARD_REF_HAS_CLASS</span><span class="s2">:</span>
            <span class="s1">allow_special_forms </span><span class="s2">= </span><span class="s0">not </span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_is_argument__</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">allow_special_forms </span><span class="s2">= </span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_is_class__</span>
        <span class="s1">type_ </span><span class="s2">= </span><span class="s1">_lax_type_check</span><span class="s2">(</span>
            <span class="s1">value</span><span class="s2">,</span>
            <span class="s1">msg</span><span class="s2">,</span>
            <span class="s1">is_argument</span><span class="s2">=</span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_is_argument__</span><span class="s2">,</span>
            <span class="s1">allow_special_forms</span><span class="s2">=</span><span class="s1">allow_special_forms</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s3"># Recursively evaluate the type</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s1">ForwardRef</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">type_</span><span class="s2">, </span><span class="s4">&quot;__forward_module__&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">) </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">globals </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s0">return </span><span class="s1">evaluate_forward_ref</span><span class="s2">(</span>
                <span class="s1">type_</span><span class="s2">,</span>
                <span class="s1">globals</span><span class="s2">=</span><span class="s1">globals</span><span class="s2">,</span>
                <span class="s1">locals</span><span class="s2">=</span><span class="s1">locals</span><span class="s2">,</span>
                 <span class="s1">type_params</span><span class="s2">=</span><span class="s1">type_params</span><span class="s2">, </span><span class="s1">owner</span><span class="s2">=</span><span class="s1">owner</span><span class="s2">,</span>
                <span class="s1">_recursive_guard</span><span class="s2">=</span><span class="s1">_recursive_guard</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s1">format</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">5</span><span class="s2">) </span><span class="s0">and </span><span class="s1">type_params</span><span class="s2">:</span>
            <span class="s3"># Make use of type_params</span>
            <span class="s1">locals </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">locals</span><span class="s2">) </span><span class="s0">if </span><span class="s1">locals </span><span class="s0">else </span><span class="s2">{}</span>
            <span class="s0">for </span><span class="s1">tvar </span><span class="s0">in </span><span class="s1">type_params</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">tvar</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s0">not in </span><span class="s1">locals</span><span class="s2">:  </span><span class="s3"># lets not overwrite something present</span>
                    <span class="s1">locals</span><span class="s2">[</span><span class="s1">tvar</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">] = </span><span class="s1">tvar</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">9</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_eval_type</span><span class="s2">(</span>
                <span class="s1">type_</span><span class="s2">,</span>
                <span class="s1">globals</span><span class="s2">,</span>
                <span class="s1">locals</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">5</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_eval_type</span><span class="s2">(</span>
                <span class="s1">type_</span><span class="s2">,</span>
                <span class="s1">globals</span><span class="s2">,</span>
                <span class="s1">locals</span><span class="s2">,</span>
                <span class="s1">recursive_guard</span><span class="s2">=</span><span class="s1">_recursive_guard </span><span class="s2">| {</span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_arg__</span><span class="s2">},</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">14</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_eval_type</span><span class="s2">(</span>
                <span class="s1">type_</span><span class="s2">,</span>
                <span class="s1">globals</span><span class="s2">,</span>
                <span class="s1">locals</span><span class="s2">,</span>
                <span class="s1">type_params</span><span class="s2">,</span>
                <span class="s1">recursive_guard</span><span class="s2">=</span><span class="s1">_recursive_guard </span><span class="s2">| {</span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_arg__</span><span class="s2">},</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">_eval_type</span><span class="s2">(</span>
            <span class="s1">type_</span><span class="s2">,</span>
            <span class="s1">globals</span><span class="s2">,</span>
            <span class="s1">locals</span><span class="s2">,</span>
            <span class="s1">type_params</span><span class="s2">,</span>
            <span class="s1">recursive_guard</span><span class="s2">=</span><span class="s1">_recursive_guard </span><span class="s2">| {</span><span class="s1">forward_ref</span><span class="s2">.</span><span class="s1">__forward_arg__</span><span class="s2">},</span>
            <span class="s1">format</span><span class="s2">=</span><span class="s1">format</span><span class="s2">,</span>
            <span class="s1">owner</span><span class="s2">=</span><span class="s1">owner</span><span class="s2">,</span>
        <span class="s2">)</span>


<span class="s3"># Aliases for items that have always been in typing.</span>
<span class="s3"># Explicitly assign these (rather than using `from typing import *` at the top),</span>
<span class="s3"># so that we get a CI error if one of these is deleted from typing.py</span>
<span class="s3"># in a future version of Python</span>
<span class="s1">AbstractSet </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">AbstractSet</span>
<span class="s1">AnyStr </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">AnyStr</span>
<span class="s1">BinaryIO </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">BinaryIO</span>
<span class="s1">Callable </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Callable</span>
<span class="s1">Collection </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Collection</span>
<span class="s1">Container </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Container</span>
<span class="s1">Dict </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Dict</span>
<span class="s1">ForwardRef </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ForwardRef</span>
<span class="s1">FrozenSet </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">FrozenSet</span>
<span class="s1">Generic </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Generic</span>
<span class="s1">Hashable </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Hashable</span>
<span class="s1">IO </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">IO</span>
<span class="s1">ItemsView </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ItemsView</span>
<span class="s1">Iterable </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Iterable</span>
<span class="s1">Iterator </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Iterator</span>
<span class="s1">KeysView </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">KeysView</span>
<span class="s1">List </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">List</span>
<span class="s1">Mapping </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Mapping</span>
<span class="s1">MappingView </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">MappingView</span>
<span class="s1">Match </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Match</span>
<span class="s1">MutableMapping </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">MutableMapping</span>
<span class="s1">MutableSequence </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">MutableSequence</span>
<span class="s1">MutableSet </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">MutableSet</span>
<span class="s1">Optional </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Optional</span>
<span class="s1">Pattern </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Pattern</span>
<span class="s1">Reversible </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Reversible</span>
<span class="s1">Sequence </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Sequence</span>
<span class="s1">Set </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Set</span>
<span class="s1">Sized </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Sized</span>
<span class="s1">TextIO </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">TextIO</span>
<span class="s1">Tuple </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Tuple</span>
<span class="s1">Union </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">Union</span>
<span class="s1">ValuesView </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">ValuesView</span>
<span class="s1">cast </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">cast</span>
<span class="s1">no_type_check </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">no_type_check</span>
<span class="s1">no_type_check_decorator </span><span class="s2">= </span><span class="s1">typing</span><span class="s2">.</span><span class="s1">no_type_check_decorator</span>
</pre>
</body>
</html>